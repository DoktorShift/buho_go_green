Directory structure:
└── getalby-js-sdk/
    ├── README.md
    ├── commitlint.config.js
    ├── jest.config.ts
    ├── lint-staged.config.js
    ├── package.json
    ├── prettierrc.json
    ├── repl.js
    ├── tsconfig.json
    ├── .eslintignore
    ├── .eslintrc.json
    ├── .node-version
    ├── .prettierignore
    ├── docs/
    │   ├── lnclient.md
    │   ├── nwc-wallet-service.md
    │   ├── nwc.md
    │   └── oauth.md
    ├── examples/
    │   ├── README.md
    │   ├── package.json
    │   ├── .yarnrc.yml
    │   ├── lnclient/
    │   │   ├── pay_ln_address.ts
    │   │   ├── paywall-esm.html
    │   │   ├── paywall.ts
    │   │   └── splitter.ts
    │   ├── nwc/
    │   │   ├── auth.html
    │   │   ├── auth_manual.html
    │   │   ├── get-balance.ts
    │   │   ├── get-info.js
    │   │   ├── keysend.js
    │   │   ├── list-transactions.js
    │   │   ├── lookup-invoice.js
    │   │   ├── make-invoice.js
    │   │   ├── multi-keysend.js
    │   │   ├── send-multi-payment.js
    │   │   ├── send-payment.js
    │   │   ├── sign-message.js
    │   │   ├── client/
    │   │   │   ├── auth.html
    │   │   │   ├── auth_manual.html
    │   │   │   ├── create-connection.js
    │   │   │   ├── get-balance.js
    │   │   │   ├── get-budget.js
    │   │   │   ├── get-info.js
    │   │   │   ├── get-wallet-service-info.js
    │   │   │   ├── get-wallet-service-supported-methods.js
    │   │   │   ├── hold-invoice.js
    │   │   │   ├── list-transactions.js
    │   │   │   ├── lookup-invoice.js
    │   │   │   ├── make-invoice.js
    │   │   │   ├── multi-pay-invoice.js
    │   │   │   ├── multi-pay-keysend.js
    │   │   │   ├── nwa-accept.js
    │   │   │   ├── nwa.js
    │   │   │   ├── pay-invoice.js
    │   │   │   ├── pay-keysend.js
    │   │   │   ├── sign-message.js
    │   │   │   └── subscribe.js
    │   │   └── wallet-service/
    │   │       └── example.js
    │   └── oauth/
    │       ├── AlbyOauthCallback.jsx
    │       ├── boostagram.js
    │       ├── decode-invoice.js
    │       ├── invoices.js
    │       ├── keysends.js
    │       ├── oauth2-public-callback_pkce_s256.mjs
    │       ├── send-to-ln-address.js
    │       └── webhooks.js
    ├── src/
    │   ├── index.ts
    │   ├── utils.ts
    │   ├── lnclient/
    │   │   ├── Amount.test.ts
    │   │   ├── Amount.ts
    │   │   ├── FiatAmount.test.ts
    │   │   ├── FiatAmount.ts
    │   │   ├── index.ts
    │   │   ├── LNClient.ts
    │   │   └── ReceiveInvoice.ts
    │   ├── nwc/
    │   │   ├── index.ts
    │   │   ├── NWAClient.test.ts
    │   │   ├── NWAClient.ts
    │   │   ├── NWCClient.test.ts
    │   │   ├── NWCClient.ts
    │   │   ├── NWCWalletService.ts
    │   │   ├── NWCWalletServiceRequestHandler.ts
    │   │   └── types.ts
    │   ├── oauth/
    │   │   ├── AlbyResponseError.test.ts
    │   │   ├── AlbyResponseError.ts
    │   │   ├── auth.ts
    │   │   ├── client.ts
    │   │   ├── helpers.ts
    │   │   ├── index.ts
    │   │   ├── OAuth2Bearer.ts
    │   │   ├── OAuth2User.ts
    │   │   ├── request.ts
    │   │   ├── types.ts
    │   │   ├── utils.ts
    │   │   └── eventEmitter/
    │   │       └── EventEmitter.ts
    │   └── webln/
    │       ├── index.ts
    │       ├── NostrWeblnProvider.ts
    │       └── OauthWeblnProvider.ts
    ├── .github/
    │   ├── dependabot.yml
    │   └── workflows/
    │       ├── ci.yml
    │       ├── docs.yml
    │       └── publish.yml
    └── .husky/
        ├── commit-msg
        └── pre-commit

================================================
FILE: README.md
================================================
# Alby JS SDK

## Introduction

Build zero-custody bitcoin payments into apps with a few lines of code.

This JavaScript SDK is for interacting with a bitcoin lightning wallet via Nostr Wallet Connect or the Alby Wallet API.

## Installing

```bash
npm install @getalby/sdk
```

or

```bash
yarn add @getalby/sdk
```

or for use without any build tools:

```html
<script type="module">
  import { LN /* or nwc, webln */ } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work

  // ... then use the SDK as normal (see below)
</script>
```

## Lightning Network Client (LN) Documentation

Quickly get started adding lightning payments to your app.

> The easiest way to provide credentials is with an [NWC connection secret](https://nwc.dev). Get one in minutes by connecting to [Alby Hub](https://albyhub.com/), [coinos](https://coinos.io/apps/new), [Primal](https://primal.net/downloads), [lnwallet.app](https://lnwallet.app/), [Yakihonne](https://yakihonne.com/), [or other NWC-enabled wallets](https://github.com/getAlby/awesome-nwc?tab=readme-ov-file#nwc-wallets).

For example, to make a payment:

```js
import { LN, USD } from "@getalby/sdk";
const credentials = "nostr+walletconnect://..."; // the NWC connection credentials
await new LN(credentials).pay("lnbc..."); // pay a lightning invoice
await new LN(credentials).pay("hello@getalby.com", USD(1)); // or pay $1 USD to a lightning address
```

Or to request to receive a payment:

```js
const request = await new LN(credentials).requestPayment(USD(1.0));
// give request.invoice to someone...
request.onPaid(giveAccess);
```

[Read more](./docs/lnclient.md)

For more flexibility you can access the underlying NWC wallet directly. Continue to read the Nostr Wallet Connect documentation below.

## Nostr Wallet Connect Documentation

[Nostr Wallet Connect](https://nwc.dev) is an open protocol enabling applications to interact with bitcoin lightning wallets. It allows users to connect their existing wallets to your application allowing developers to easily integrate bitcoin lightning functionality.

For apps, see [NWC client and NWA client documentation](./docs/nwc.md)

For wallet services, see [NWC wallet service documentation](./docs/nwc-wallet-service.md)

## Alby Wallet API Documentation

The [Alby OAuth API](https://guides.getalby.com/alby-wallet-api/reference/getting-started) allows you to integrate bitcoin lightning functionality provided by the Alby Wallet into your applications, with the Alby Wallet API. Send & receive payments, create invoices, setup payment webhooks, access Podcasting 2.0 and more!

[Read more](./docs/oauth.md)

### NodeJS

#### Fetch

**This library relies on a global fetch() function which will work in browsers and node v18.x or newer.** (In older versions you have to use a polyfill.)

#### Websocket polyfill

To use this on Node.js you first must install `websocket-polyfill@0.0.3` and import it:

```js
import "websocket-polyfill";
// or: require('websocket-polyfill');
```

## WebLN Documentation

The JS SDK also has some implementations for [WebLN](https://webln.guide).
See the [NostrWebLNProvider documentation](./docs/nwc.md) and [OAuthWebLNProvider documentation](./docs/oauth.md).

## More Documentation

Read the [auto-generated documentation](https://getalby.github.io/js-sdk/modules.html)

## Need help?

We are happy to help, please contact us or create an issue.

- [Twitter: @getAlby](https://twitter.com/getAlby)
- [Telegram Community Chat](https://t.me/getAlby)
- e-mail to support@getalby.com
- [bitcoin.design](https://bitcoin.design/) Slack community [#lightning-browser-extension](https://bitcoindesign.slack.com/archives/C02591ADXM2)
- Read the [Alby developer guide](https://guides.getalby.com/developer-guide) to better understand how Alby packages and APIs can be used to power your app.

## Thanks

The client and the setup is inspired and based on the [twitter-api-typescript-sdk](https://github.com/twitterdev/twitter-api-typescript-sdk).

## License

MIT



================================================
FILE: commitlint.config.js
================================================
export default {
    extends: ['@commitlint/config-conventional']
  };


================================================
FILE: jest.config.ts
================================================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
};


================================================
FILE: lint-staged.config.js
================================================
export default {
    "src/**/*.{js,ts}": [
      "eslint --fix --max-warnings 0",
      "prettier --write"
    ],
    "examples/**/*.{js,mjs,jsx}": [
      "prettier --write"
    ],
  
    "package.json": ["prettier --write"],
    "src/**/*.ts": () => "tsc --noEmit",
  };
  


================================================
FILE: package.json
================================================
{
  "name": "@getalby/sdk",
  "version": "5.1.0",
  "description": "The SDK to integrate with Nostr Wallet Connect and the Alby API",
  "repository": "https://github.com/getAlby/js-sdk.git",
  "bugs": "https://github.com/getAlby/js-sdk/issues",
  "funding": {
    "type": "lightning",
    "url": "lightning:hello@getalby.com"
  },
  "type": "module",
  "source": "src/index.ts",
  "main": "./dist/index.umd.js",
  "module": "./dist/index.module.js",
  "unpkg": "./dist/index.umd.js",
  "types": "./dist/index.d.ts",
  "files": [
    "dist/**/*"
  ],
  "exports": {
    "require": "./dist/index.cjs",
    "types": "./dist/index.d.ts",
    "default": "./dist/index.modern.js"
  },
  "scripts": {
    "prebuild": "yarn run clean",
    "lint": "yarn lint:js && yarn tsc:compile && yarn format:fix",
    "lint:js": "eslint src --ext .js,.ts --max-warnings 0",
    "lint:js:fix": "eslint src --ext .js,.ts --fix",
    "tsc:compile": "tsc --noEmit",
    "format": "prettier --check '**/*.(md|json)' 'src/**/*.(js|ts)' 'examples/**/*.(js|jsx)'",
    "format:fix": "prettier --loglevel silent --write '**/*.(md|json)' 'src/**/*.(js|ts)' 'examples/**/*.(js|jsx)'",
    "prepack": "yarn run build",
    "test": "jest",
    "clean": "rm -rf dist",
    "build": "microbundle --no-sourcemap",
    "dev": "microbundle watch",
    "prepare": "husky"
  },
  "dependencies": {
    "nostr-tools": "2.13.2",
    "@getalby/lightning-tools": "^5.1.2"
  },
  "devDependencies": {
    "@commitlint/cli": "^19.4.1",
    "@commitlint/config-conventional": "^19.4.1",
    "@types/jest": "^29.5.5",
    "@types/node": "^22.15.21",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^6.3.0",
    "@webbtc/webln-types": "^3.0.0",
    "eslint": "^8.46.0",
    "eslint-config-prettier": "^10.1.5",
    "express": "^5.1.0",
    "husky": "^9.1.7",
    "jest": "^29.7.0",
    "lint-staged": "^16.0.0",
    "microbundle": "^0.15.1",
    "prettier": "^3.0.1",
    "qrcode-terminal": "^0.12.0",
    "ts-jest": "^29.3.4",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6",
    "websocket-polyfill": "^0.0.3"
  },
  "engines": {
    "node": ">=14"
  },
  "author": "Alby contributors",
  "license": "MIT"
}



================================================
FILE: prettierrc.json
================================================
{
  "trailingComma": "all"
}



================================================
FILE: repl.js
================================================
import * as repl from 'node:repl';
import { auth, Client, webln } from "./dist/index.module.js";
import 'websocket-polyfill';
try {
  globalThis.crypto = await import('node:crypto');
} catch (err) {
  console.error('crypto not found!');
}

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: ["invoices:read", "account:read", "balance:read", "invoices:create", "invoices:read", "payments:send"],
  token: { access_token: process.env.ACCESS_TOKEN, refresh_token: process.env.REFRESH_TOKEN, expires_at: undefined } // initialize with existing token
});


console.log('Welcome to the alby-js-sdk REPL');

if (!process.env.CLIENT_ID) {
  console.log("Configure the environment variable `CLIENT_ID` and option; `CLIENT_SECRET`, `ACCESS_TOKEN`");
  process.exit();
}

console.log('use `authClient` and `alby` (the client)');


const r = repl.start('> ');
r.context.webln = webln;
r.context.authClient = authClient;
r.context.alby = new Client(authClient);



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "checkJs": true,
    "allowJs": true,
    "declarationMap": false,
    "declaration": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2020",
    "module": "ESNext",
    "rootDir": "./src",
    "sourceMap": false,
    "moduleResolution": "node"
  },
  "ts-node": {
    "esm": true
  },
  "include": ["src/**/*"],
  "exclude": ["examples/*", "scripts/*"]
}



================================================
FILE: .eslintignore
================================================
node_modules
dist



================================================
FILE: .eslintrc.json
================================================
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "sourceType": "module",
    "ecmaVersion": 2020
  },
  "plugins": ["@typescript-eslint"],
  "env": {
    "node": true
  },
  "rules": {
    "@typescript-eslint/ban-ts-comment": [
      "error",
      {
        "ts-ignore": "allow-with-description"
      }
    ],
    "@typescript-eslint/no-unused-vars": ["warn", { "args": "none" }],
    "no-console": ["error", { "allow": ["info", "warn", "error"] }],
    "no-constant-binary-expression": "error"
  },
  "globals": {
    "window": true
  }
}



================================================
FILE: .node-version
================================================
18.12.1



================================================
FILE: .prettierignore
================================================
# Ignore artifacts:
dist
node_modules


================================================
FILE: docs/lnclient.md
================================================
# Lightning Network Client (LN) Documentation

The LN class helps you easily get started interacting with the lightning network. It is a high level wrapper around the [NWCClient](./nwc.md) which is compatible with many different lightning wallets.

See [LNClient class documentation](https://getalby.github.io/js-sdk/classes/LNClient.html)

For example, to make a payment:

```js
import { LN, USD, SATS } from "@getalby/sdk";
const credentials = "nostr+walletconnect://..."; // the NWC connection credentials
await new LN(credentials).pay("lnbc..."); // pay a lightning invoice
await new LN(credentials).pay("hello@getalby.com", SATS(21)); // or pay 21 sats to a lightning address
await new LN(credentials).pay("hello@getalby.com", USD(1)); // or pay $1 USD to a lightning address
await new LN(credentials).pay("hello@getalby.com", new FiatAmount(1, "THB")); // or pay an amount in any currency to a lightning address
await new LN(credentials).pay("hello@getalby.com", USD(1), {
  metadata: { comment: "Example comment", payer_data: { name: "Bob" } },
}); // set a comment for the payment you are making, and that the payment was made by Bob
```

Or to request to receive a payment:

```js
const request = await new LN(credentials).requestPayment(USD(1.0));

// give request.invoice to someone, then act upon it:
request
  .onPaid(giveAccess) // listen for incoming payment and then fire the given method
  .onTimeout(60, showTimeout); // if they didn't pay within 60 seconds, do something else
```

## Examples

See [the LNClient examples directory](./examples/lnclient) for a full list of examples.

## For Node.js

To use this on Node.js you first must install `websocket-polyfill@0.0.3` and import it:

```js
import "websocket-polyfill";
// or: require('websocket-polyfill');
```

if you get an `crypto is not defined` error, either upgrade to node.js 20 or above, or import it manually:

```js
import * as crypto from 'crypto'; // or 'node:crypto'
globalThis.crypto = crypto as any;
//or: global.crypto = require('crypto');
```



================================================
FILE: docs/nwc-wallet-service.md
================================================
# Nostr Wallet Connect - Wallet Service Documentation

[Nostr Wallet Connect](https://nwc.dev) is an open protocol enabling applications to interact with bitcoin lightning wallets. It allows users to connect apps they use to your wallet service, allowing app developers to easily integrate bitcoin lightning functionality.

The Alby JS SDK allows you to easily integrate Nostr Wallet Connect into any JavaScript based lightning wallet to allow client applications to easily connect and seamlessly interact with the wallet.

> See [NWCWalletService class documentation](https://getalby.github.io/js-sdk/classes/nwc.NWCWalletService.html)

## NWCWalletService

### Initialization Options

- `relayUrl`: URL of the Nostr relay to be used (e.g. wss://relay.getalby.com/v1)

### NWCWalletService quick start example

See [the full example](/examples/nwc/wallet-service/example.js)

```js
import { nwc } from "@getalby/sdk";

const walletService = new nwc.NWCWalletService({
  relayUrl: "wss://relay.getalby.com/v1",
});

// now for each client/app connection you can publish a NIP-47 info event and subscribe to requests

await walletService.publishWalletServiceInfoEvent(
  walletServiceSecretKey,
  ["get_info"], // NIP-47 methods supported by your wallet service
  [],
);

// each client connection will have a unique keypair

const keypair = new nwc.NWCWalletServiceKeyPair(
  walletServiceSecretKey,
  clientPubkey,
);

const unsub = await walletService.subscribe(keypair, {
  getInfo: () => {
    return Promise.resolve({
      result: {
        methods: ["get_info"],
        alias: "Alby Hub",
        //... add other fields here
      },
      error: undefined,
    });
  },
  // ... handle other NIP-47 methods here
});
```



================================================
FILE: docs/nwc.md
================================================
# Nostr Wallet Connect Documentation

[Nostr Wallet Connect](https://nwc.dev) is an open protocol enabling applications to interact with bitcoin lightning wallets. It allows users to connect their existing wallets to your application allowing developers to easily integrate bitcoin lightning functionality.

The Alby JS SDK allows you to easily integrate Nostr Wallet Connect into any JavaScript based application.

There are two interfaces you can use to access NWC:

- The `NWCClient` exposes the [NWC](https://nwc.dev/) interface directly, which is more powerful than the WebLN interface and is recommended if you plan to create an application outside of the web (e.g. native mobile/command line/server backend etc.). You can explore all the examples [here](../examples/nwc/client/).
- The `NostrWebLNProvider` exposes the [WebLN](https://webln.guide/) interface to execute lightning wallet functionality through Nostr Wallet Connect, such as sending payments, making invoices and getting the node balance. You can explore all the examples [here](../examples/nwc/). See also [Bitcoin Connect](https://github.com/getAlby/bitcoin-connect/) if you are developing a frontend web application.

> See [NWCClient class documentation](https://getalby.github.io/js-sdk/classes/nwc.NWCClient.html)

## NWCClient

### Initialization Options

- `nostrWalletConnectUrl`: full Nostr Wallet Connect URL as defined by the [spec](https://github.com/getAlby/nips/blob/master/47.md)
- `relayUrl`: URL of the Nostr relay to be used (e.g. wss://relay.getalby.com/v1)
- `walletPubkey`: pubkey of the Nostr Wallet Connect app
- `secret`: secret key to sign the request event (if not available window.nostr will be used)

### NWCClient Quick start example

```js
import { nwc } from "@getalby/sdk";
const nwcClient = new nwc.NWCClient({
  nostrWalletConnectUrl: loadNWCUrl(),
}); // loadNWCUrl is some function to get the NWC URL from some (encrypted) storage

// now you can send payments by passing in the invoice in an object
const response = await nwcClient.payInvoice({ invoice });
```

### `static fromAuthorizationUrl()`

Initialized a new `NWCClient` instance but generates a new random secret. The pubkey of that secret then needs to be authorized by the user (this can be initiated by redirecting the user to the `getAuthorizationUrl()` URL or calling `fromAuthorizationUrl()` to open an authorization popup.

```js
const nwcClient = await nwc.NWCClient.fromAuthorizationUrl(
  "https://my.albyhub.com/apps/new",
  {
    name: "My app name",
  },
);
```

The same options can be provided to getAuthorizationUrl() as fromAuthorizationUrl() - see [Manual Auth example](../examples/nwc/client/auth_manual.html)

### Examples

See [the NWC client examples directory](../examples/nwc/client) for a full list of examples.

## NostrWebLNProvider

> See [NostrWebLNProvider class documentation](https://getalby.github.io/js-sdk/classes/webln.NostrWebLNProvider.html)

### Initialization Options

- `nostrWalletConnectUrl`: full Nostr Wallet Connect URL as defined by the [spec](https://github.com/getAlby/nips/blob/master/47.md)
- `relayUrl`: URL of the Nostr relay to be used (e.g. wss://relay.getalby.com/v1)
- `walletPubkey`: pubkey of the Nostr Wallet Connect app
- `secret`: secret key to sign the request event (if not available window.nostr will be used)
- `client`: initialize using an existing NWC client

### WebLN Quick start example

```js
import { webln } from "@getalby/sdk";
const nwc = new webln.NostrWebLNProvider({
  nostrWalletConnectUrl: loadNWCUrl(),
}); // loadNWCUrl is some function to get the NWC URL from some (encrypted) storage
// or use the short version
const nwc = new webln.NWC({ nostrWalletConnectUrl: loadNWCUrl });

// connect to the relay
await nwc.enable();

// now you can send payments by passing in the invoice
const response = await nwc.sendPayment(invoice);
```

You can use NWC as a webln compatible object in your web app:

```js
// you can set the window.webln object to use the universal API to send payments:
if (!window.webln) {
  // prompt the user to connect to NWC
  window.webln = new webln.NostrWebLNProvider({
    nostrWalletConnectUrl: loadNWCUrl,
  });
  // now use any webln code
}
```

## NostrWebLNProvider Functions

The goal of the Nostr Wallet Connect provider is to be API compatible with [webln](https://www.webln.guide/). Currently not all methods are supported - see the examples/nwc directory for a list of supported methods.

### sendPayment(invoice: string)

Takes a bolt11 invoice and calls the NWC `pay_invoice` function.
It returns a promise object that is resolved with an object with the preimage or is rejected with an error

#### Payment Example

```js
import { webln } from "@getalby/sdk";
const nwc = new webln.NostrWebLNProvider({ nostrWalletConnectUrl: loadNWCUrl });
await nwc.enable();
const response = await nwc.sendPayment(invoice);
console.log(response);
```

#### getNostrWalletConnectUrl()

Returns the `nostr+walletconnect://` URL which includes all the connection information (`walletPubkey`, `relayUrl`, `secret`)
This can be used to get and persist the string for later use.

#### fromAuthorizationUrl(url: string, {name: string})

Opens a new window prompt with at the provided authorization URL to ask the user to authorize the app connection.
The promise resolves when the connection is authorized and the popup sends a `nwc:success` message or rejects when the prompt is closed.
Pass a `name` to the NWC provider describing the application.

```js
import { webln } from "@getalby/sdk";

try {
  const nwc = await webln.NostrWebLNProvider.fromAuthorizationUrl(
    "https://my.albyhub.com/apps/new",
    {
      name: "My app name",
    },
  );
} catch (e) {
  console.error(e);
}
await nwc.enable();
let response;
try {
  response = await nwc.sendPayment(invoice);
  // if success then the response.preimage will be only
  console.info(`payment successful, the preimage is ${response.preimage}`);
} catch (e) {
  console.error(e.error || e);
}
```

#### React Native (Expo)

Look at our [NWC React Native Expo Demo app](https://github.com/getAlby/nwc-react-native-expo) for how to use NWC in a React Native expo project.

#### For Node.js

To use this on Node.js you first must install `websocket-polyfill@0.0.3` and import it:

```js
import "websocket-polyfill";
// or: require('websocket-polyfill');
```

if you get an `crypto is not defined` error, either upgrade to node.js 20 or above, or import it manually:

```js
import * as crypto from 'crypto'; // or 'node:crypto'
globalThis.crypto = crypto as any;
//or: global.crypto = require('crypto');
```

### Examples

#### Defaults

```js
import { webln } from "@getalby/sdk";

const nwc = new webln.NostrWebLNProvider(); // use defaults (connects to Alby's relay, will use window.nostr to sign the request)
await nwc.enable(); // connect to the relay
const response = await nwc.sendPayment(invoice);
console.log(response.preimage);

nwc.close(); // close the websocket connection
```

#### Use a custom, user provided Nostr Wallet Connect URL

```js
import { webln } from "@getalby/sdk";

const nwc = new webln.NostrWebLNProvider({
  nostrWalletConnectUrl:
    "nostr+walletconnect://69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9?relay=wss://nostr.bitcoiner.social&secret=c60320b3ecb6c15557510d1518ef41194e9f9337c82621ddef3f979f668bfebd",
}); // use defaults
await nwc.enable(); // connect to the relay
const response = await nwc.sendPayment(invoice);
console.log(response.preimage);

nwc.close(); // close the websocket connection
```

#### Generate a new NWC connect url using a locally-generated secret

```js
// use the `fromAuthorizationUrl` helper which opens a popup to initiate the connection flow.
// the promise resolves once the NWC app returned.
const nwc = await webln.NostrWebLNProvider.fromAuthorizationUrl(
  "https://my.albyhub.com/apps/new",
  {
    name: "My app name",
  },
);

// ... enable and send a payment

// if you want to get the connect url with the secret:
// const nostrWalletConnectUrl nwc.getNostrWalletConnectUrl(true)
```

The same options can be provided to getAuthorizationUrl() as fromAuthorizationUrl() - see [Manual Auth example](../examples/nwc/auth_manual.html)

### Nostr Wallet Auth

NWA is an alternative flow for lightning apps to easily initialize an NWC connection to mobile-first or self-custodial wallets, using a client-created secret.

The app will generate an NWA URI which should be opened in the wallet, where the user can approve the connection.

> See [NWAClient class documentation](https://getalby.github.io/js-sdk/classes/nwc.NWAClient.html)

#### Generating an NWA URI (For Client apps)

```js
import { nwa } from "@getalby/sdk";
const connectionUri = new nwa.NWAClient({
  relayUrl,
  requestMethods: ["get_info"],
}).connectionUri;

// then allow the user to copy it / display it as a QR code to the user
```

See full [NWA example](../examples/nwc/client/nwa.js)

### Accepting and creating a connection from an NWA URI (For Wallet services)

```js
import { nwa } from "@getalby/sdk";
const nwaOptions = nwa.NWAClient.parseWalletAuthUrl(nwaUrl);

// then use `nwaOptions` to display a confirmation page to the user and create a connection.
```

See full [NWA accept example](../examples/nwc/client/nwa-accept.js) for NWA URI parsing and handling. The implementation of actually creating the connection and showing a confirmation page to the user is wallet-specific. In the example, a connection will be created via the `create_connection` NWC command.



================================================
FILE: docs/oauth.md
================================================
# OAuth API Documentation

Please have a look at the Alby OAuth2 Wallet API:

[https://guides.getalby.com/alby-wallet-api/reference/getting-started](https://guides.getalby.com/alby-wallet-api/reference/getting-started)

## Available methods

- accountBalance
- accountSummary
- signMessage
- accountInformation
- accountValue4Value
- invoices
- incomingInvoices
- outgoingInvoices
- getInvoice
- createInvoice
- decodeInvoice
- keysend
- sendPayment
- sendBoostagram
- sendBoostagramToAlbyAccount
- createWebhookEndpoint
- deleteWebhookEndpoint

### Examples

#### Full OAuth Authentication flow

```js
const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

const authUrl = await authClient.generateAuthURL({
  code_challenge_method: "S256",
  // authorizeUrl: "https://getalby.com/oauth"  endpoint for authorization (replace with the appropriate URL based on the environment)
});
// open auth URL
// `code` is passed as a query parameter when the user is redirected back after authorization
await authClient.requestAccessToken(code);

// access the token response. You can store this securely for future client initializations
console.log(authClient.token);

// initialize a client
const client = new Client(authClient);

const result = await client.accountBalance();
```

#### Initialize a client from existing token details

```js
const token = loadTokenForUser(); // {access_token: string, refresh_token: string, expires_at: number}
const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: token,
});

const client = new Client(authClient);
// the authClient will automatically refresh the access token if expired using the refresh token
const result = await client.createInvoice({ amount: 1000 });
```

#### Handling refresh token

Access tokens do expire. If an access token is about to expire, this library will automatically use a refresh token to retrieve a fresh one. Utilising the _tokenRefreshed_ event is a simple approach to guarantee that you always save the most recent tokens.

If token refresh fails, you can restart the OAuth Authentication flow or log the error by listening for the _tokenRefreshFailed_ event.

(Note: To prevent losing access to the user's token, only initialize one instance of the client per token pair at a time)

```js
const token = loadTokenForUser(); // {access_token: string, refresh_token: string, expires_at: number}
const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: token,
});

// listen to the tokenRefreshed event
authClient.on("tokenRefreshed", (tokens) => {
  // store the tokens in database
  console.log(tokens);
});

// Listen to the tokenRefreshFailed event
authClient.on("tokenRefreshFailed", (error) => {
  // Handle the token refresh failure, for example, log the error or launch OAuth authentication flow
  console.error("Token refresh failed:", error.message);
});
```

#### Sending payments

```js
const token = loadTokenForUser(); // {access_token: string, refresh_token: string, expires_at: number}
const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: token,
});

const client = new Client(authClient);
// the authClient will automatically refresh the access token if expired using the refresh token

await client.sendPayment({ invoice: bolt11 });

await client.keysend({
  destination: nodekey,
  amount: 10,
  memo: memo,
});
```

#### Send a boostagram

refer also to the boostagram spec: [BLIP-10](https://github.com/lightning/blips/blob/master/blip-0010.md)

```js
const token = loadTokenForUser(); // {access_token: string, refresh_token: string, expires_at: number}
const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  callback: "http://localhost:8080/callback",
  scopes: ["payments:send"],
  token: token,
});

const client = new Client(authClient);
// the authClient will automatically refresh the access token if expired using the refresh token

// pass in an array if you want to send multiple boostagrams with one call
await client.sendBoostagram({
  recipient: {
    address:
      "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
    customKey: "696969",
    customValue: "bNVHj0WZ0aLPPAesnn9M",
  },
  amount: 10,
  // spec: https://github.com/lightning/blips/blob/master/blip-0010.md
  boostagram: {
    app_name: "Alby SDK Demo",
    value_msat_total: 49960, // TOTAL Number of millisats for the payment (all splits together, before fees. The actual number someone entered in their player, for numerology purposes.)
    value_msat: 2121, // Number of millisats for this split payment
    url: "https://feeds.buzzsprout.com/xxx.rss",
    podcast: "Podcast title",
    action: "boost",
    episode: "The episode title",
    episode_guid: "Buzzsprout-xxx",
    ts: 574,
    name: "Podcaster - the recipient name",
    sender_name: "Satoshi - the sender/listener name",
  },
});

// or manually through the keysend:

// pass in an array if you want to do multiple keysend payments with one call
await client.keysend({
  destination: nodekey,
  amount: 10,
  customRecords: {
    7629169: JSON.stringify(boostagram),
    696969: "user",
  },
});
```

#### Send multiple boostagrams

You often want to send a boostagram for multiple splits. You can do this with one API call. Simply pass in an array of boostagrams. See example above.

```js
const response = await client.sendBoostagram([
  boostagram1,
  boostagram2,
  boostagram3,
]);

console.log(response.keysends);
```

`response.keysends` is an array of objects that either has an `error` key if a payment failed or the `keysend` key if everything succeeded.

```json
{
  "keysends": [
    {
      "keysend": {
        "amount": 10,
        "fee": 0,
        "destination": "xx",
        "payment_preimage": "xx",
        "payment_hash": "xx"
      }
    },
    {
      "keysend": {
        "amount": 10,
        "fee": 0,
        "destination": "xxx",
        "payment_preimage": "xxx",
        "payment_hash": "xxx"
      }
    }
  ]
}
```

#### Decoding an invoice

For quick invoice decoding without an API request please see Alby's [Lightning Tools package](https://github.com/getAlby/js-lightning-tools#basic-invoice-decoding).

For more invoice details you can use the Alby Wallet API:

```js
const decodedInvoice = await client.decodeInvoice(paymentRequest);
const {payment_hash, amount, description, ...} = decodedInvoice;
```

## fetch() dependency

This library relies on a global `fetch()` function which will only work in browsers and node v18.x or newer. In older versions you can manually install a global fetch option or polyfill if needed.

For example:

```js
import fetch from "cross-fetch"; // or "@inrupt/universal-fetch"
globalThis.fetch = fetch;

// or as a polyfill:
import "cross-fetch/polyfill";
```

## Full usage examples

You can find examples in the [examples/](../examples/oauth/) directory.



================================================
FILE: examples/README.md
================================================
# Alby SDK Examples

This directory contains example scripts demonstrating how to use the [`@getalby/sdk`](https://github.com/getAlby/js-sdk) for various Bitcoin, Lightning, and Nostr Wallet Connect use cases.

## ✅ Prerequisites

Before running the examples, make sure to install and build the Alby SDK from the root directory:

```bash
cd ..
yarn install
yarn build
```

## 📦 Setup

1. Navigate to the examples directory:

```bash
cd examples
```

2. Then install dependencies:

```bash
yarn install
```

## ▶️ Running an Example

Use `tsx` to run a specific TypeScript file. For example:

```bash
yarn tsx ./lnclient/pay_ln_address.ts
```

Make sure you’ve installed the dev dependencies and TypeScript properly.

## 📁 Folder Structure

- `lnclient/`: Contains Lightning client examples. This is a good place to start.

## 🧠 Notes

- All examples should be written in **TypeScript** for type safety.
- Designed to test features against a locally built version of the SDK.
- Contributions are welcome! Feel free to submit more examples or improvements.

## Legacy examples

Some older examples are still in JavaScript and can be run using node:

```bash
node ./nwc/client/get-balance.js
```

---

Made with ⚡ by the Alby contributors.



================================================
FILE: examples/package.json
================================================
{
  "name": "alby-sdk-examples",
  "version": "1.0.0",
  "description": "Example usage of the Alby SDK including Nostr Wallet Connect and Lightning utilities",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "tsx ./lnclient/pay_ln_address.ts"
  },
  "dependencies": {
    "@getalby/sdk": "portal:../",
    "websocket-polyfill": "^0.0.3"
  },
  "devDependencies": {
    "tsx": "^4.19.4",
    "typescript": "^5.1.6"
  },
  "engines": {
    "node": ">=14"
  },
  "author": "Alby contributors",
  "license": "MIT",
  "packageManager": "yarn@4.9.0"
}



================================================
FILE: examples/.yarnrc.yml
================================================
nodeLinker: node-modules



================================================
FILE: examples/lnclient/pay_ln_address.ts
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { LN, USD } from "@getalby/sdk";

async function main(): Promise<void> {
  const rl = readline.createInterface({ input, output });

  const nwcUrl =
    process.env.NWC_URL ||
    (await rl.question(
      "Nostr Wallet Connect URL (nostr+walletconnect://...): ",
    ));
  rl.close();

  const client = new LN(nwcUrl);
  console.info("Paying $1");
  try {
    const response = await client.pay("hello@getalby.com", USD(1.0), {
      metadata: {
        comment: "Payment from TypeScript SDK",
        payer_data: { name: "Bob" },
      },
    });

    console.info("Paid successfully:", response);
  } catch (error) {
    console.error("Payment failed:", error);
  } finally {
    client.close(); 
  }
}

main().catch((err) => {
  console.error("Unexpected error:", err);
});



================================================
FILE: examples/lnclient/paywall-esm.html
================================================
<script type="module">
  import { LN, USD } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work
  const connectionSecret = prompt("Enter a read-only connection secret");
  const client = new LN(connectionSecret);

  // request a lightning invoice that we show the user to pay
  const request = await client.requestPayment(USD(1.0), {
    description: "best content",
  });

  prompt(
    "Please copy and pay the above invoice. Once you close the dialog, make sure to pay the invoice within 60 seconds.",
    request.invoice.paymentRequest,
  );

  // once the invoice got paid by the user run this callback
  request
    .onPaid(() => {
      alert("received payment!");
      client.close(); // when done and no longer needed close the wallet connection
    })
    .onTimeout(60, () => {
      alert("didn't receive payment in time.");
      client.close(); // when done and no longer needed close the wallet connection
    });
</script>



================================================
FILE: examples/lnclient/paywall.ts
================================================
import "websocket-polyfill"; // required in node.js
import qrcode from "qrcode-terminal";

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { LN, USD } from "@getalby/sdk";

const rl = readline.createInterface({ input, output });

async function main(): Promise<void> {
  const nwcUrl =
    process.env.NWC_URL ||
    (await rl.question(
      "Nostr Wallet Connect URL (nostr+walletconnect://...): ",
    ));
  rl.close();

  const client = new LN(nwcUrl);

  // request a lightning invoice that we show the user to pay
  const request = await client.requestPayment(USD(1.0), {
    description: "best content",
  });

  qrcode.generate(request.invoice.paymentRequest, { small: true });
  console.info(request.invoice.paymentRequest);
  console.info("Please pay the above invoice within 60 seconds.");
  console.info("Waiting for payment...");

  // once the invoice got paid by the user run this callback
  request
    .onPaid(() => {
      console.info("received payment!");
      client.close(); // when done and no longer needed close the wallet connection
      process.exit();
    })
    .onTimeout(60, () => {
      console.info("didn't receive payment in time.");
      client.close(); // when done and no longer needed close the wallet connection
      process.exit();
    });

  process.on("SIGINT", function () {
    console.info("Caught interrupt signal");
    client.close();
    process.exit();
  });
}

main().catch((err) => {
  console.error("Unexpected error:", err);
});



================================================
FILE: examples/lnclient/splitter.ts
================================================
import "websocket-polyfill"; // required in node.js
import qrcode from "qrcode-terminal";

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { LN, USD, SATS } from "@getalby/sdk";

/*
 * This example shows how to use the Alby SDK to create a split payment
 * where a user pays an invoice and the payment is split between multiple
 * recipients. The user pays a single invoice, and the server forwards the
 * payment to multiple recipients based on a specified percentage.
 */

async function main(): Promise<void> {
  const rl = readline.createInterface({ input, output });

  const nwcUrl =
    process.env.NWC_URL ||
    (await rl.question(
      "Nostr Wallet Connect URL (nostr+walletconnect://...): ",
    ));
  rl.close();

  const amount = USD(1.0);
  const recipients = ["rolznz@getalby.com", "hello@getalby.com"];
  const forwardPercentage = 50;

  const client = new LN(nwcUrl);

  // request an lightning invoice
  const request = await client.requestPayment(amount, {
    description: "prism payment",
  });

  // prompt the user to pay the invoice
  qrcode.generate(request.invoice.paymentRequest, { small: true });
  console.info(request.invoice.paymentRequest);
  console.info("Please pay the above invoice within 60 seconds.");
  console.info("Waiting for payment...");

  // once the invoice got paid by the user run this callback
  request
    .onPaid(async () => {
      // we take the sats amount from theinvocie and calculate the amount we want to forward
      const satsReceived = request.invoice.satoshi;
      const satsToForward = Math.floor(
        (satsReceived * forwardPercentage) / 100 / recipients.length,
      );
      console.info(
        `Received ${satsReceived} sats! Forwarding ${satsToForward} to ${recipients.join(", ")}`,
      );

      // iterate over all recipients and pay them the amount
      await Promise.all(
        recipients.map(async (r) => {
          const response = await client.pay(r, SATS(satsToForward), {
            metadata: { comment: "splitter" },
          });
          console.info(
            `Forwarded ${satsToForward} sats to ${r} (preimage: ${response.preimage})`,
          );
        }),
      );
      client.close(); // when done and no longer needed close the wallet connection
      process.exit();
    })
    .onTimeout(60, () => {
      console.info("didn't receive payment in time.");
      client.close(); // when done and no longer needed close the wallet connection
      process.exit();
    });

  process.on("SIGINT", function () {
    console.info("Caught interrupt signal");
    process.exit();
  });
}

main().catch((err) => {
  console.error("Unexpected error:", err);
});



================================================
FILE: examples/nwc/auth.html
================================================
<script type="module">
  import { webln } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work
  window.launchNwc = async () => {
    try {
      const authUrl = prompt("Auth URL", "https://my.albyhub.com/apps/new");
      const nwcWebln = await webln.NostrWebLNProvider.fromAuthorizationUrl(
        authUrl,
        {
          name: "Deeplink " + Date.now(),
        },
      );
      // connect to the relay
      await nwcWebln.enable();
      const result = await nwcWebln.getInfo();
      alert("Info response: " + JSON.stringify(result));
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  };
</script>

<button onclick="window.launchNwc()">Connect NWC</button>



================================================
FILE: examples/nwc/auth_manual.html
================================================
<button id="connect-button" onclick="window.launchNwc()">Connect NWC</button>
<button id="reset-button" onclick="window.resetNwc()">Reset</button>

<script type="module">
  import { webln, nwc } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work
  import {
    generateSecretKey,
    getPublicKey,
  } from "https://esm.sh/nostr-tools@2.9.4"; // jsdelivr.net, skypack.dev also work
  import {
    bytesToHex,
    hexToBytes,
  } from "https://esm.sh/@noble/hashes@1.3.1/utils"; // jsdelivr.net, skypack.dev also work

  const params = new URL(window.location.href).searchParams;
  const walletPubkey = params.get("pubkey");
  const relayUrl = params.get("relay");
  const lud16 = params.get("lud16");
  const secret = window.localStorage.getItem("demo_secret");

  if (walletPubkey && relayUrl) {
    try {
      if (!secret) {
        throw new Error("No secret saved locally");
      }
      window.document.getElementById("connect-button").remove();
      const nwcClient = new nwc.NWCClient({
        secret,
        walletPubkey,
        relayUrl,
        lud16,
      });
      const weblnProvider = new webln.NostrWebLNProvider({
        client: nwcClient,
      });
      await weblnProvider.enable();
      const result = await weblnProvider.getInfo();
      alert("Info response: " + JSON.stringify(result) + " lud16: " + lud16);
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  } else {
    window.document.getElementById("reset-button").remove();
  }

  window.resetNwc = async () => {
    window.localStorage.removeItem("demo_secret");
    window.location.href = window.origin;
  };

  window.launchNwc = async () => {
    try {
      if (!window.origin.startsWith("http")) {
        alert(
          "Please use a webserver from this directory e.g. python3 -m http.server",
        );
      }

      const secret = bytesToHex(generateSecretKey());
      const pubkey = getPublicKey(hexToBytes(secret));
      window.localStorage.setItem("demo_secret", secret);
      const authorizationBasePath = prompt(
        "Auth URL",
        "https://my.albyhub.com/apps/new",
      );
      const authUrl = await nwc.NWCClient.getAuthorizationUrl(
        authorizationBasePath,
        {
          name: "Deeplink " + Date.now(),
          returnTo: window.location.href,
        },
        pubkey,
      );
      window.location = authUrl;
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  };
</script>



================================================
FILE: examples/nwc/get-balance.ts
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "@getalby/sdk";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.getBalance();

console.info(response);

webln.close();



================================================
FILE: examples/nwc/get-info.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.getInfo();

console.info(response);

webln.close();



================================================
FILE: examples/nwc/keysend.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.keysend({
  amount: 1,
  destination:
    "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
  customRecords: {
    696969: "017rsl75kNnSke4mMHYE", // hello@getalby.com
    34349334: "example keysend message",
  },
});

console.info(response);

webln.close();



================================================
FILE: examples/nwc/list-transactions.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();

const ONE_WEEK_IN_SECONDS = 60 * 60 * 24 * 7;
const response = await webln.listTransactions({
  from: Math.floor(new Date().getTime() / 1000 - ONE_WEEK_IN_SECONDS),
  until: Math.ceil(new Date().getTime() / 1000),
  limit: 30,
  // type: "incoming",
  // unpaid: true,
});

console.info(
  response.transactions.length + " transactions, ",
  response.transactions.filter((t) => t.type === "incoming").length +
    " incoming",
  response,
);

webln.close();



================================================
FILE: examples/nwc/lookup-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

const invoiceOrPaymentHash = await rl.question("Invoice or payment hash: ");
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.lookupInvoice({
  // provide one of the below
  paymentRequest: invoiceOrPaymentHash.startsWith("ln")
    ? invoiceOrPaymentHash
    : undefined,
  paymentHash: !invoiceOrPaymentHash.startsWith("ln")
    ? invoiceOrPaymentHash
    : undefined,
});

console.info(response);

webln.close();



================================================
FILE: examples/nwc/make-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.makeInvoice({
  amount: 1, // in sats
  defaultMemo: "NWC WebLN example",
});

console.info(response);

webln.close();



================================================
FILE: examples/nwc/multi-keysend.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();

const keysends = [
  {
    destination:
      "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
    amount: 1,
    customRecords: {
      696969: "017rsl75kNnSke4mMHYE", // hello@getalby.com
      34349334: "First keysend",
    },
  },
  {
    destination:
      "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
    amount: 1,
    customRecords: {
      696969: "1KOZHzhLs2U7JIx3BmEY", // another Alby account
      34349334: "second keysend",
    },
  },
];

try {
  const response = await webln.multiKeysend(keysends);
  console.info(JSON.stringify(response));
} catch (error) {
  console.error("multiKeysend failed", error);
}

webln.close();



================================================
FILE: examples/nwc/send-multi-payment.js
================================================
import "websocket-polyfill"; // required in node.js

import { LightningAddress } from "@getalby/lightning-tools";

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const ln = new LightningAddress(process.env.LN_ADDRESS || "hello@getalby.com");
// fetch the LNURL data
await ln.fetch();

// generate 2 invoices to pay
const invoices = (
  await Promise.all(
    [1, 2].map((v) =>
      ln.requestInvoice({
        satoshi: 1,
        comment: `Multi-pay invoice #${v}`,
      }),
    ),
  )
).map((invoice) => invoice.paymentRequest);

console.info("Generated two invoices", invoices);

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
try {
  const response = await webln.sendMultiPayment(invoices);
  console.info(response);
} catch (error) {
  console.error("sendMultiPayment failed", error);
}

webln.close();



================================================
FILE: examples/nwc/send-payment.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
const invoice = await rl.question("Lightning invoice: ");
rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.sendPayment(invoice);

console.info(response);

webln.close();



================================================
FILE: examples/nwc/sign-message.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { webln as providers } from "../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

rl.close();

const webln = new providers.NostrWebLNProvider({
  nostrWalletConnectUrl: nwcUrl,
});
await webln.enable();
const response = await webln.signMessage("Hello, world!");

console.info(response);

webln.close();



================================================
FILE: examples/nwc/client/auth.html
================================================
<script type="module">
  import { nwc } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work

  window.launchNwc = async () => {
    try {
      const authUrl = prompt("Auth URL", "https://my.albyhub.com/apps/new");
      const nwcClient = await nwc.NWCClient.fromAuthorizationUrl(authUrl, {
        name: "Deeplink " + Date.now(),
      });
      const result = await nwcClient.getInfo();
      alert("Info response: " + JSON.stringify(result));
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  };
</script>

<button onclick="window.launchNwc()">Connect NWC</button>



================================================
FILE: examples/nwc/client/auth_manual.html
================================================
<button id="connect-button" onclick="window.launchNwc()">Connect NWC</button>
<button id="reset-button" onclick="window.resetNwc()">Reset</button>

<script type="module">
  import { nwc } from "https://esm.sh/@getalby/sdk@5.1.0"; // jsdelivr.net, skypack.dev also work
  import {
    generateSecretKey,
    getPublicKey,
  } from "https://esm.sh/nostr-tools@2.9.4"; // jsdelivr.net, skypack.dev also work
  import {
    bytesToHex,
    hexToBytes,
  } from "https://esm.sh/@noble/hashes@1.3.1/utils"; // jsdelivr.net, skypack.dev also work

  const params = new URL(window.location.href).searchParams;
  const walletPubkey = params.get("pubkey");
  const relayUrl = params.get("relay");
  const lud16 = params.get("lud16");
  const secret = window.localStorage.getItem("demo_secret");

  if (walletPubkey && relayUrl) {
    try {
      if (!secret) {
        throw new Error("No secret saved locally");
      }
      window.document.getElementById("connect-button").remove();
      const nwcClient = new nwc.NWCClient({
        secret,
        walletPubkey,
        relayUrl,
        lud16,
      });
      const result = await nwcClient.getInfo();
      alert("Info response: " + JSON.stringify(result) + " lud16: " + lud16);
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  } else {
    window.document.getElementById("reset-button").remove();
  }

  window.resetNwc = async () => {
    window.localStorage.removeItem("demo_secret");
    window.location.href = window.origin;
  };

  window.launchNwc = async () => {
    try {
      if (!window.origin.startsWith("http")) {
        alert(
          "Please use a webserver from this directory e.g. python3 -m http.server",
        );
      }

      const secret = bytesToHex(generateSecretKey());
      const pubkey = getPublicKey(hexToBytes(secret));
      window.localStorage.setItem("demo_secret", secret);
      const authorizationBasePath = prompt(
        "Auth URL",
        "https://my.albyhub.com/apps/new",
      );
      const authUrl = await nwc.NWCClient.getAuthorizationUrl(
        authorizationBasePath,
        {
          name: "Deeplink " + Date.now(),
          returnTo: window.location.href,
        },
        pubkey,
      );
      window.location = authUrl;
    } catch (error) {
      console.error(error);
      alert("Something went wrong: " + error);
    }
  };
</script>



================================================
FILE: examples/nwc/client/create-connection.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";
import { generateSecretKey, getPublicKey } from "nostr-tools";

import { bytesToHex } from "@noble/hashes/utils";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

let secretKey = generateSecretKey();
let pubkey = getPublicKey(secretKey);

const response = await client.createConnection({
  pubkey,
  name: "Test created app from JS SDK " + new Date().toISOString(),
  request_methods: [
    "get_info",
    "get_balance",
    "get_budget",
    "make_invoice",
    "pay_invoice",
    "lookup_invoice",
    "list_transactions",
    "sign_message",
  ],
});

console.info(response);

client.close();

const childClient = new nwc.NWCClient({
  relayUrl: client.relayUrl,
  secret: bytesToHex(secretKey),
  walletPubkey: response.wallet_pubkey,
});

const info = await childClient.getInfo();
console.info("Got info from created app", info);

childClient.close();



================================================
FILE: examples/nwc/client/get-balance.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.getBalance();

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/get-budget.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.getBudget();

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/get-info.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.getInfo();

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/get-wallet-service-info.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.getWalletServiceInfo();

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/get-wallet-service-supported-methods.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.getWalletServiceSupportedMethods();

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/hold-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

const amount =
  parseInt((await rl.question("Amount in sats (default 1 sat): ")) || "1") *
  1000;

rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const toHexString = (bytes) =>
  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");

const preimageBytes = crypto.getRandomValues(new Uint8Array(32));
const preimage = toHexString(preimageBytes);

const hashBuffer = await crypto.subtle.digest("SHA-256", preimageBytes);
const paymentHashBytes = new Uint8Array(hashBuffer);
const paymentHash = toHexString(paymentHashBytes);

const response = await client.makeHoldInvoice({
  amount, // in millisats
  description: "NWC HODL invoice example",
  payment_hash: paymentHash,
  // or set a 256-bit description hash:
  //description_hash: "a40f2b27a4414044995b26b73eb5aa66688b5f18d6a8a2513827d9a116ad95f1",
});

console.info(response.invoice);

const onNotification = async (notification) => {
  if (notification.notification.payment_hash !== paymentHash) {
    console.info("Skipping unrelated notification", notification);
    return;
  }
  console.info(
    "HOLD invoice accepted! It can be settled or canceled before block " +
      notification.notification.settle_deadline,
  );

  const rl = readline.createInterface({ input, output });

  const action = await rl.question("Type settle or cancel: ");

  rl.close();
  if (action === "settle") {
    console.info("Chose to settle invoice");
    await client.settleHoldInvoice({ preimage });
  } else {
    console.info("Chose to cancel invoice");
    await client.cancelHoldInvoice({ payment_hash: paymentHash });
  }
  process.exit();
};

const unsub = await client.subscribeNotifications(onNotification, [
  "hold_invoice_accepted",
]);

console.info("Waiting for payment to be made...");
process.on("SIGINT", function () {
  console.info("Caught interrupt signal");

  unsub();
  client.close();

  process.exit();
});



================================================
FILE: examples/nwc/client/list-transactions.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const ONE_WEEK_IN_SECONDS = 60 * 60 * 24 * 7;
const response = await client.listTransactions({
  from: Math.floor(new Date().getTime() / 1000 - ONE_WEEK_IN_SECONDS),
  until: Math.ceil(new Date().getTime() / 1000),
  limit: 30,
  // type: "incoming",
  // unpaid: true,
});

console.info(
  response.transactions.length + " transactions, ",
  response.transactions.filter((t) => t.type === "incoming").length +
    " incoming",
  response,
);

client.close();



================================================
FILE: examples/nwc/client/lookup-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

const invoiceOrPaymentHash = await rl.question("Invoice or payment hash: ");
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const response = await client.lookupInvoice({
  // provide one of the below
  invoice: invoiceOrPaymentHash.startsWith("ln")
    ? invoiceOrPaymentHash
    : undefined,
  payment_hash: !invoiceOrPaymentHash.startsWith("ln")
    ? invoiceOrPaymentHash
    : undefined,
});

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/make-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

const amount =
  parseInt((await rl.question("Amount in sats (default 1 sat): ")) || "1") *
  1000;

rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const response = await client.makeInvoice({
  amount, // in millisats
  description: "NWC Client example",
  // or set a 256-bit description hash:
  //description_hash: "a40f2b27a4414044995b26b73eb5aa66688b5f18d6a8a2513827d9a116ad95f1",
});

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/multi-pay-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import { LightningAddress } from "@getalby/lightning-tools";

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const ln = new LightningAddress(process.env.LN_ADDRESS || "hello@getalby.com");
// fetch the LNURL data
await ln.fetch();

// generate 2 invoices to pay
const invoices = (
  await Promise.all(
    [1, 2].map((v) =>
      ln.requestInvoice({
        satoshi: 1,
        comment: `Multi-pay invoice #${v}`,
      }),
    ),
  )
).map((invoice) => invoice.paymentRequest);

console.info("Generated two invoices", invoices);

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

try {
  const response = await client.multiPayInvoice({
    invoices: invoices.map((invoice) => ({
      invoice,
    })),
  });
  console.info(response);
} catch (error) {
  console.error("multi_pay_invoice failed", error);
}

client.close();



================================================
FILE: examples/nwc/client/multi-pay-keysend.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

// Data from https://podcastindex.org/podcast/920666
const boost = {
  action: "boost",
  value_msat: 1000,
  value_msat_total: 1000,
  app_name: "⚡ WebLN Demo",
  app_version: "1.0",
  feedID: "https://feeds.podcastindex.org/pc20.xml",
  podcast: "Podcasting 2.0",
  episode: "Episode 104: A New Dump",
  ts: 21,
  name: "⚡ WebLN Demo",
  sender_name: "Satoshi Nakamoto",
  message: "Go podcasting!",
};

// from https://stackoverflow.com/a/50868276
const toHexString = (bytes) =>
  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");

const keysends = [
  {
    pubkey:
      "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
    amount: 1000, // millisats
    tlv_records: [
      {
        type: 696969,
        value: toHexString(new TextEncoder().encode("017rsl75kNnSke4mMHYE")), // hello@getalby.com
      },
      {
        type: 7629169,
        value: toHexString(new TextEncoder().encode(JSON.stringify(boost))),
      },
    ],
  },
  {
    pubkey:
      "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
    amount: 1000, // millisats
    tlv_records: [
      {
        type: 696969,
        value: toHexString(new TextEncoder().encode("1KOZHzhLs2U7JIx3BmEY")), // another Alby account
      },
      {
        type: 7629169,
        value: toHexString(new TextEncoder().encode(JSON.stringify(boost))),
      },
    ],
  },
];

try {
  const response = await client.multiPayKeysend({ keysends });
  console.info(JSON.stringify(response));
} catch (error) {
  console.error("multi_pay_keysend failed", error);
}

client.close();



================================================
FILE: examples/nwc/client/nwa-accept.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwa, nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question(
    "Nostr Wallet Connect URL (nostr+walletconnect://...) with create_connection method: ",
  ));

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const infoResponse = await client.getInfo();

if (infoResponse.methods.indexOf("create_connection") < 0) {
  console.error("this connection does not support NWC create_connection");
  process.exit(1);
}

const nwaUrl = await rl.question(
  "Nostr Wallet Auth URL (nostr+walletauth://...): ",
);

const nwaOptions = nwa.NWAClient.parseWalletAuthUrl(nwaUrl);

// (here the user would choose to accept the connection)

const createAppResponse = await client.createConnection({
  pubkey: nwaOptions.appPubkey,
  name: nwaOptions.name || "NWA test " + new Date().toISOString(),
  request_methods: nwaOptions.requestMethods,
  notification_types: nwaOptions.notificationTypes,
  max_amount: nwaOptions.maxAmount,
  budget_renewal: nwaOptions.budgetRenewal,
  expires_at: nwaOptions.expiresAt,
  isolated: nwaOptions.isolated,
  metadata: nwaOptions.metadata,
});

console.info(createAppResponse);

rl.close();
client.close();



================================================
FILE: examples/nwc/client/nwa.js
================================================
import "websocket-polyfill"; // required in node.js
import qrcode from "qrcode-terminal";

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwa } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const DEFAULT_RELAY_URL = "wss://relay.getalby.com/v1";

const relayUrl =
  (await rl.question(`Relay URL (${DEFAULT_RELAY_URL}): `)) ||
  DEFAULT_RELAY_URL;
rl.close();

const nwaClient = new nwa.NWAClient({
  relayUrl,
  requestMethods: ["get_info"],
});

console.info("Scan or enter the following NWA connection URI in your wallet:");

// this prints the QR code
qrcode.generate(nwaClient.connectionUri, { small: true });

console.info(nwaClient.connectionUri);

console.info("\nWaiting for connection...");

await nwaClient.subscribe({
  onSuccess: async (nwcClient) => {
    console.info("NWA successful", nwcClient.options);
    const response = await nwcClient.getInfo();

    console.info(response);

    nwcClient.close();
  },
});



================================================
FILE: examples/nwc/client/pay-invoice.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
const invoice = await rl.question("Lightning invoice: ");
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const response = await client.payInvoice({ invoice });

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/pay-keysend.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

// from https://stackoverflow.com/a/50868276
const toHexString = (bytes) =>
  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");

// Data from https://podcastindex.org/podcast/920666
const boost = {
  action: "boost",
  value_msat: 1000,
  value_msat_total: 1000,
  app_name: "⚡ WebLN Demo",
  app_version: "1.0",
  feedID: "https://feeds.podcastindex.org/pc20.xml",
  podcast: "Podcasting 2.0",
  episode: "Episode 104: A New Dump",
  ts: 21,
  name: "⚡ WebLN Demo",
  sender_name: "Satoshi Nakamoto",
  message: "Go podcasting!",
};

const response = await client.payKeysend({
  amount: 1000, // millisats
  pubkey: "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
  tlv_records: [
    {
      type: 696969,
      value: toHexString(new TextEncoder().encode("017rsl75kNnSke4mMHYE")), // hello@getalby.com
    },
    {
      type: 7629169,
      value: toHexString(new TextEncoder().encode(JSON.stringify(boost))),
    },
  ],
});

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/sign-message.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));

rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});
const response = await client.signMessage({
  message: "Hello, world!",
});

console.info(response);

client.close();



================================================
FILE: examples/nwc/client/subscribe.js
================================================
import "websocket-polyfill"; // required in node.js

import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { nwc } from "../../../dist/index.module.js";

const rl = readline.createInterface({ input, output });

const nwcUrl =
  process.env.NWC_URL ||
  (await rl.question("Nostr Wallet Connect URL (nostr+walletconnect://...): "));
rl.close();

const client = new nwc.NWCClient({
  nostrWalletConnectUrl: nwcUrl,
});

const onNotification = (notification) =>
  console.info("Got notification", notification);

const unsub = await client.subscribeNotifications(onNotification);

console.info("Waiting for notifications...");
process.on("SIGINT", function () {
  console.info("Caught interrupt signal");

  unsub();
  client.close();

  process.exit();
});



================================================
FILE: examples/nwc/wallet-service/example.js
================================================
import "websocket-polyfill"; // required in node.js

import { generateSecretKey, getPublicKey } from "nostr-tools";
import { bytesToHex, hexToBytes } from "@noble/hashes/utils";

const walletServiceSecretKey = bytesToHex(generateSecretKey());
const walletServicePubkey = getPublicKey(hexToBytes(walletServiceSecretKey));

const clientSecretKey = bytesToHex(generateSecretKey());
const clientPubkey = getPublicKey(hexToBytes(clientSecretKey));

const relayUrl = "wss://relay.getalby.com/v1";

const nwcUrl = `nostr+walletconnect://${walletServicePubkey}?relay=${relayUrl}&secret=${clientSecretKey}`;

console.info("enter this NWC URL in a client: ", nwcUrl);

import { nwc } from "../../../dist/index.module.js";

const walletService = new nwc.NWCWalletService({
  relayUrl,
});

await walletService.publishWalletServiceInfoEvent(
  walletServiceSecretKey,
  ["get_info"],
  [],
);

const keypair = new nwc.NWCWalletServiceKeyPair(
  walletServiceSecretKey,
  clientPubkey,
);

const unsub = await walletService.subscribe(keypair, {
  getInfo: () => {
    return Promise.resolve({
      result: {
        methods: ["get_info"],
        alias: "Alby Hub",
        //... add other fields here
      },
      error: undefined,
    });
  },
  // ... handle other NIP-47 methods here
});

console.info("Waiting for events...");
process.on("SIGINT", function () {
  console.info("Caught interrupt signal");

  unsub();
  walletService.close();

  process.exit();
});



================================================
FILE: examples/oauth/AlbyOauthCallback.jsx
================================================
import { useEffect, useState } from "react";

const AlbyOauthCallback = () => {
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!window.opener) {
      alert(
        "Something went wrong. Opener not available. Please contact support@getalby.com",
      );
      return;
    }
    const params = new URLSearchParams(window.location.search);
    const code = params.get("code");
    const error = params.get("error");

    if (!code) {
      setError("declined");
    }
    if (error) {
      setError(error);
      alert(error);
      return;
    }

    window.opener.postMessage({
      type: "alby:oauth:success",
      payload: { code },
    });
    console.log("auth message published");
  }, []);

  return (
    <div>
      {error && <p>Authorization failed: {error}</p>}
      {!error && <p>Connected. you can close this window.</p>}
    </div>
  );
};

export default AlbyOauthCallback;



================================================
FILE: examples/oauth/boostagram.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;

const rl = readline.createInterface({ input, output });

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

// use an array if you want to send multiple boostagrams with one call
const response = await client.sendBoostagram([
  {
    recipient: {
      address:
        "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
      customKey: "696969",
      customValue: "bNVHj0WZ0aLPPAesnn9M",
    },
    amount: 10,
    // spec: https://github.com/lightning/blips/blob/master/blip-0010.md
    boostagram: {
      app_name: "Alby SDK Demo",
      value_msat_total: 49960, // TOTAL Number of millisats for the payment (all splits together, before fees. The actual number someone entered in their player, for numerology purposes.)
      value_msat: 2121, // Number of millisats for this split payment
      url: "https://feeds.buzzsprout.com/xxx.rss",
      podcast: "Podcast title",
      action: "boost",
      episode: "The episode title",
      episode_guid: "Buzzsprout-xxx",
      ts: 574,
      name: "Podcaster - the recipient name",
      sender_name: "Satoshi - the sender/listener name",
    },
  },
]);

console.log(JSON.stringify(response));



================================================
FILE: examples/oauth/decode-invoice.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";
import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;

const rl = readline.createInterface({ input, output });

const paymentRequest =
  "lnbc10u1pj4t6w0pp54wm83znxp8xly6qzuff2z7u6585rnlcw9uduf2haa42qcz09f5wqdq023jhxapqd4jk6mccqzzsxqyz5vqsp5mlvjs8nktpz98s5dcrhsuelrz94kl2vjukvu789yzkewast6m00q9qyyssqupynqdv7e5y8nlul0trva5t97g7v3gwx7akhu2dvu4pn66eu2pr5zkcnegp8myz3wrpj9ht06pwyfn4dvpmnr96ejq6ygex43ymaffqq3gud4d";

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080",
  scopes: ["invoices:read"], // this scope isn't needed, but at least one scope is required to get an access token
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

const response = await client.decodeInvoice(paymentRequest);

console.log(JSON.stringify(response, null, 2));



================================================
FILE: examples/oauth/invoices.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;

const rl = readline.createInterface({ input, output });

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080",
  scopes: ["invoices:read", "account:read", "balance:read"],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

const response = await client.incomingInvoices();

console.log(JSON.stringify(response, null, 2));

if (response[0]) {
  const invoice = await client.getInvoice(response[0].r_hash_str);
  console.log(JSON.stringify(invoice, null, 2));
}



================================================
FILE: examples/oauth/keysends.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;

const rl = readline.createInterface({ input, output });

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

const response = client.keysend([
  {
    amount: 10,
    destination:
      "03006fcf3312dae8d068ea297f58e2bd00ec1ffe214b793eda46966b6294a53ce6",
    customRecords: { 34349334: "I love amboss" },
  },
  {
    amount: 11,
    destination:
      "03006fcf3312dae8d068ea297f58e2bd00ec1ffe214b793eda46966b6294a53ce6",
    customRecords: { 34349334: "I love amboss" },
  },
]);

console.log(JSON.stringify(response));



================================================
FILE: examples/oauth/oauth2-public-callback_pkce_s256.mjs
================================================
import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;
import express from "express";

if (!process.env.CLIENT_ID || !process.env.CLIENT_SECRET) {
  throw new Error("Please set CLIENT_ID and CLIENT_SECRET");
}

const app = express();

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

const client = new Client(authClient);

const STATE = "my-state";

app.get("/callback", async function (req, res) {
  try {
    const { code, state } = req.query;
    if (state !== STATE) return res.status(500).send("State isn't matching");
    await authClient.requestAccessToken(code);
    console.log(authClient);
    const invoices = await client.accountBalance();
    res.send(invoices);
  } catch (error) {
    console.log(error);
  }
});

app.get("/login", async function (req, res) {
  const authUrl = await authClient.generateAuthURL({
    state: STATE,
    code_challenge_method: "S256",
  });
  res.redirect(authUrl);
});

app.get("/balance", async function (req, res) {
  const result = await client.accountBalance();
  res.send(result);
});

app.get("/summary", async function (req, res) {
  const result = await client.accountSummary();
  res.send(result);
});

app.get("/value4value", async function (req, res) {
  const result = await client.accountValue4Value();
  res.send(result);
});

app.get("/make-invoice", async function (req, res) {
  const result = await client.createInvoice({ amount: 1000 });
  res.send(result);
});

app.get("/bolt11/:invoice", async function (req, res) {
  const result = await client.sendPayment({ invoice: req.params.invoice });
  res.send(result);
});

app.get("/keysend/:destination", async function (req, res) {
  const result = await client.keysend({
    destination: req.params.destination,
    amount: 10,
    memo: req.query.memo,
  });
  res.send(result);
});

app.get("/refresh", async function (req, res) {
  try {
    await authClient.refreshAccessToken();
    res.send("Refreshed Access Token");
  } catch (error) {
    console.log(error);
  }
});

app.listen(8080, () => {
  console.log(`Go here to login: http://localhost:8080/login`);
});



================================================
FILE: examples/oauth/send-to-ln-address.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;
import { LightningAddress } from "alby-tools";

const rl = readline.createInterface({ input, output });

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080",
  scopes: ["payments:send"],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

const ln = new LightningAddress("hello@getalby.com");
// fetch the LNURL data
await ln.fetch();

const invoice = await ln.requestInvoice({ satoshi: 1000 });

const response = await client.sendPayment({ invoice: invoice.paymentRequest });

console.log(JSON.stringify(response, null, 2));



================================================
FILE: examples/oauth/webhooks.js
================================================
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

import { oauth } from "../../dist/index.module.js";
const { auth, Client } = oauth;

const rl = readline.createInterface({ input, output });

const authClient = new auth.OAuth2User({
  client_id: process.env.CLIENT_ID,
  client_secret: process.env.CLIENT_SECRET,
  callback: "http://localhost:8080/callback",
  scopes: [
    "invoices:read",
    "account:read",
    "balance:read",
    "invoices:create",
    "invoices:read",
    "payments:send",
  ],
  token: {
    access_token: undefined,
    refresh_token: undefined,
    expires_at: undefined,
  }, // initialize with existing token
});

console.log(`Open the following URL and authenticate the app:`);
console.log(await authClient.generateAuthURL());
console.log("----\n");

const code = await rl.question("Code: (localhost:8080?code=[THIS CODE]: ");
rl.close();

await authClient.requestAccessToken(code);
console.log(authClient.token);
const client = new Client(authClient);

// Create a webhook
response = await alby.createWebhookEndpoint({
  url: "https://example.com",
  filter_types: ["invoice.settled"],
});

// Delete a webhook
// response = await alby.deleteWebhookEndpoint('ep_...').then(console.log)

console.log(JSON.stringify(response));



================================================
FILE: src/index.ts
================================================
export * as oauth from "./oauth";
export * as webln from "./webln";
export * as nwc from "./nwc";
export * from "./lnclient";



================================================
FILE: src/utils.ts
================================================
// from https://stackoverflow.com/a/50868276
export const toHexString = (bytes: Uint8Array) =>
  bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");



================================================
FILE: src/lnclient/Amount.test.ts
================================================
import { resolveAmount, SATS } from "./Amount";

describe("Amount", () => {
  test("SATS", async () => {
    const amount = SATS(10);
    expect(amount.satoshi).toBe(10);
  });
  test("resolveAmount", async () => {
    const resolved = await resolveAmount({ satoshi: 10 });
    expect(resolved.satoshi).toBe(10);
    expect(resolved.millisat).toBe(10_000);
  });
  test("resolveAmount async", async () => {
    const resolved = await resolveAmount({
      satoshi: new Promise((resolve) => setTimeout(() => resolve(10), 300)),
    });
    expect(resolved.satoshi).toBe(10);
    expect(resolved.millisat).toBe(10_000);
  });
});



================================================
FILE: src/lnclient/Amount.ts
================================================
// TODO: move to lightning tools
/**
 * An amount in satoshis
 */
export type Amount = { satoshi: number } | { satoshi: Promise<number> };

export const SATS: (amount: number) => Amount = (amount) => ({
  satoshi: amount,
});

export async function resolveAmount(
  amount: Amount,
): Promise<{ satoshi: number; millisat: number }> {
  if (typeof amount === "number") {
    return {
      satoshi: amount,
      millisat: amount * 1000,
    };
  }
  const satoshi = await Promise.resolve(amount.satoshi);

  return {
    satoshi: satoshi,
    millisat: satoshi * 1000,
  };
}



================================================
FILE: src/lnclient/FiatAmount.test.ts
================================================
import { resolveAmount } from "./Amount";
import { USD } from "./FiatAmount";

describe("FiatAmount", () => {
  test("interoperable with Amount", async () => {
    const fiatAmount = USD(1);
    const resolved = await resolveAmount(fiatAmount);
    expect(resolved.satoshi).toBeGreaterThan(0);
  });
});



================================================
FILE: src/lnclient/FiatAmount.ts
================================================
import { fiat } from "@getalby/lightning-tools";

// TODO: move to Lightning Tools
export class FiatAmount {
  satoshi: Promise<number>;
  constructor(amount: number, currency: string) {
    this.satoshi = fiat.getSatoshiValue({
      amount,
      currency,
    });
  }
}

// Most popular fiat currencies
export const USD = (amount: number) => new FiatAmount(amount, "USD");
export const EUR = (amount: number) => new FiatAmount(amount, "EUR");
export const JPY = (amount: number) => new FiatAmount(amount, "JPY");
export const GBP = (amount: number) => new FiatAmount(amount, "GBP");
export const CHF = (amount: number) => new FiatAmount(amount, "CHF");



================================================
FILE: src/lnclient/index.ts
================================================
export * from "./LNClient";
export * from "./ReceiveInvoice";
export * from "./Amount";
export * from "./FiatAmount";



================================================
FILE: src/lnclient/LNClient.ts
================================================
import { Invoice, LightningAddress } from "@getalby/lightning-tools";
import { Nip47MakeInvoiceRequest, Nip47PayInvoiceRequest } from "../nwc/types";
import { NewNWCClientOptions, NWCClient } from "../nwc/NWCClient";
import { ReceiveInvoice } from "./ReceiveInvoice";
import { Amount, resolveAmount } from "./Amount";

export type LNClientCredentials = string | NWCClient | NewNWCClientOptions;

/**
 * A simple lightning network client to interact with your lightning wallet
 */
export class LNClient {
  readonly nwcClient: NWCClient;

  /**
   * Create a new LNClient
   * @param credentials credentials to connect to a NWC-based wallet. This can be a NWC connection string e.g. nostr+walletconnect://... or an existing NWC Client. Learn more at https://nwc.dev
   */
  constructor(credentials: LNClientCredentials) {
    if (typeof credentials === "string") {
      this.nwcClient = new NWCClient({
        nostrWalletConnectUrl: credentials,
      });
    } else if (credentials instanceof NWCClient) {
      this.nwcClient = credentials;
    } else {
      this.nwcClient = new NWCClient(credentials);
    }
  }

  /**
   * Make a payment
   * @param recipient a BOLT-11 invoice or lightning address
   * @param amount the amount to pay, only required if paying to a lightning address or the amount is not specified in the BOLT 11 invoice.
   * @param args additional options, e.g. to store metadata on the payment
   * @returns the receipt of the payment, and details of the paid invoice.
   */
  async pay(
    recipient: string,
    amount?: Amount,
    args?: Omit<Nip47PayInvoiceRequest, "invoice" | "amount">,
  ) {
    let invoice = recipient;
    const parsedAmount = amount ? await resolveAmount(amount) : undefined;
    if (invoice.indexOf("@") > -1) {
      if (!parsedAmount) {
        throw new Error(
          "Amount must be provided when paying to a lightning address",
        );
      }
      const ln = new LightningAddress(recipient);
      await ln.fetch();
      const invoiceObj = await ln.requestInvoice({
        satoshi: parsedAmount.satoshi,
        comment: args?.metadata?.comment,
        payerdata: args?.metadata?.payer_data,
      });
      invoice = invoiceObj.paymentRequest;
    }

    const result = await this.nwcClient.payInvoice({
      ...(args || {}),
      invoice,
      amount: parsedAmount?.millisat,
    });
    return {
      ...result,
      invoice: new Invoice({ pr: invoice }),
    };
  }

  /**
   * Request to receive a payment
   * @param amount the amount requested, either in sats (e.g. {satoshi: 21}) or fiat (e.g. new FiatAmount(21, "USD")).
   * @param args additional options, e.g. to set a description on the payment request, or store metadata for the received payment
   * @returns the invoice to be paid, along with methods to easily listen for a payment and act upon it.
   */
  async requestPayment(
    amount: Amount,
    args?: Omit<Nip47MakeInvoiceRequest, "amount">,
  ) {
    const parsedAmount = await resolveAmount(amount);
    const transaction = await this.nwcClient.makeInvoice({
      ...(args || {}),
      amount: parsedAmount.millisat,
    });

    return new ReceiveInvoice(this.nwcClient, transaction);
  }

  close() {
    this.nwcClient.close();
  }
}

export { LNClient as LN };



================================================
FILE: src/lnclient/ReceiveInvoice.ts
================================================
import { Invoice } from "@getalby/lightning-tools";
import { Nip47Notification, Nip47Transaction, NWCClient } from "../nwc";

/**
 * A lightning invoice to be received by your wallet, along with utility functions,
 * such as checking if the invoice was paid and acting upon it.
 */
export class ReceiveInvoice {
  readonly transaction: Nip47Transaction;
  readonly invoice: Invoice;
  private _nwcClient: NWCClient;
  private _unsubscribeFunc?: () => void;
  private _timeoutFunc?: () => void;
  private _timeoutId?: number | NodeJS.Timeout;

  constructor(nwcClient: NWCClient, transaction: Nip47Transaction) {
    this.transaction = transaction;
    this.invoice = new Invoice({ pr: transaction.invoice });
    this._nwcClient = nwcClient;
  }

  /**
   * Setup an action once the invoice has been paid.
   *
   * @param callback this method will be fired once we register the invoice was paid, with information of the received payment.
   * @returns the current instance for method chaining e.g. add optional timeout
   */
  onPaid(
    callback: (receivedPayment: Nip47Transaction) => void,
  ): ReceiveInvoice {
    (async () => {
      let supportsNotifications;
      try {
        // TODO: is there a better way than calling getInfo here?
        const info = await this._nwcClient.getInfo();
        supportsNotifications =
          info.notifications?.includes("payment_received");
      } catch (error) {
        console.error("failed to fetch info, falling back to polling");
      }

      const callbackWrapper = (receivedPayment: Nip47Transaction) => {
        this._unsubscribeFunc?.();
        callback(receivedPayment);
      };

      const unsubscribeWrapper = (unsubscribe: () => void) => {
        return () => {
          // cancel the timeout method and
          this._timeoutFunc = undefined;
          clearTimeout(this._timeoutId);
          unsubscribe();
        };
      };

      if (!supportsNotifications) {
        console.warn(
          "current connection does not support notifications, falling back to polling",
        );
        this._unsubscribeFunc = unsubscribeWrapper(
          this._onPaidPollingFallback(callbackWrapper),
        );
      } else {
        const onNotification = (notification: Nip47Notification) => {
          if (
            notification.notification.payment_hash ===
            this.transaction.payment_hash
          ) {
            callbackWrapper(notification.notification);
          }
        };

        this._unsubscribeFunc = unsubscribeWrapper(
          await this._nwcClient.subscribeNotifications(onNotification, [
            "payment_received",
          ]),
        );
      }
    })();

    return this;
  }

  /**
   * Setup an action that happens if the invoice is not paid after a certain amount of time.
   *
   * @param seconds the number of seconds to wait for a payment
   * @param callback this method will be called once the timeout is elapsed.
   * @returns the current instance for method
   */
  onTimeout(seconds: number, callback: () => void): ReceiveInvoice {
    this._timeoutFunc = () => {
      this._unsubscribeFunc?.();
      callback();
    };
    this._timeoutId = setTimeout(() => {
      this._timeoutFunc?.();
    }, seconds * 1000);

    return this;
  }

  /**
   * Manually unsubscribe if you no longer expect the user to pay.
   *
   * This is only needed if no payment was received and no timeout was configured.
   */
  unsubscribe() {
    this._unsubscribeFunc?.();
  }

  private _onPaidPollingFallback(
    callback: (receivedPayment: Nip47Transaction) => void,
  ) {
    let subscribed = true;
    const unsubscribeFunc = () => {
      subscribed = false;
    };
    (async () => {
      while (subscribed) {
        const transaction = await this._nwcClient.lookupInvoice({
          payment_hash: this.transaction.payment_hash,
        });
        if (transaction.settled_at && transaction.preimage) {
          callback(transaction);
          subscribed = false;
          break;
        }
        // sleep for 3 seconds per lookup attempt
        await new Promise((resolve) => setTimeout(resolve, 3000));
      }
    })();

    return unsubscribeFunc;
  }
}



================================================
FILE: src/nwc/index.ts
================================================
export * from "./types";
export * from "./NWCClient";
export * from "./NWAClient";
export * from "./NWCWalletService";
export * from "./NWCWalletServiceRequestHandler";



================================================
FILE: src/nwc/NWAClient.test.ts
================================================
import "websocket-polyfill";
import { NWAClient } from "./NWAClient";
import { bytesToHex, hexToBytes } from "@noble/hashes/utils";
import { generateSecretKey, getPublicKey } from "nostr-tools";
import { Nip47Method, Nip47NotificationType } from "./types";

describe("NWA URI", () => {
  test("constructs correct connection URI with custom app secret key", () => {
    const appSecretKey = bytesToHex(generateSecretKey());
    const appPubkey = getPublicKey(hexToBytes(appSecretKey));

    const nwaClient = new NWAClient({
      relayUrl: "wss://relay.getalby.com/v1",
      appSecretKey,
      requestMethods: ["get_info"],
    });

    expect(nwaClient.connectionUri).toEqual(
      `nostr+walletauth://${appPubkey}?relay=${encodeURIComponent(nwaClient.options.relayUrl)}&request_methods=get_info`,
    );
  });
  test("constructs correct connection URI", () => {
    const expiresAt = Date.now() + 1000 * 60 * 60 * 24 * 30; // 30 days
    const maxAmount = 1000_000; // 1000 sats
    const nwaClient = new NWAClient({
      name: "App Name",
      icon: "https://example.com/image.png",
      relayUrl: "wss://relay.getalby.com/v1",
      requestMethods: ["get_info", "pay_invoice"],
      notificationTypes: ["payment_received", "payment_sent"],
      expiresAt,
      budgetRenewal: "monthly",
      maxAmount,
      isolated: true,
      metadata: { message: "hello world" },
      returnTo: "https://example.com",
    });

    expect(nwaClient.connectionUri).toEqual(
      `nostr+walletauth://${nwaClient.options.appPubkey}?relay=wss%3A%2F%2Frelay.getalby.com%2Fv1&request_methods=get_info%20pay_invoice&name=App%20Name&icon=https%3A%2F%2Fexample.com%2Fimage.png&return_to=https%3A%2F%2Fexample.com&notification_types=payment_received%20payment_sent&max_amount=${maxAmount}&budget_renewal=monthly&expires_at=${expiresAt}&isolated=true&metadata=%7B%22message%22%3A%22hello%20world%22%7D`,
    );
  });

  test("constructs correct connection URI for specific app", () => {
    const nwaClient = new NWAClient({
      relayUrl: "wss://relay.getalby.com/v1",
      requestMethods: ["get_info"],
    });

    expect(nwaClient.getConnectionUri("alby")).toEqual(
      `nostr+walletauth+alby://${nwaClient.options.appPubkey}?relay=wss%3A%2F%2Frelay.getalby.com%2Fv1&request_methods=get_info`,
    );
  });

  for (const scheme of [
    "nostr+walletauth://",
    "nostr+walletauth:",
    "nostr+walletauth+alby://",
    "nostr+walletauth+alby:",
  ]) {
    test(`parses connection URI (${scheme})`, () => {
      const nwaOptions = NWAClient.parseWalletAuthUrl(
        `${scheme}e73575d76c731102aefd4eb6fb0ddfaaf335eabe60255a22e6ca5e7074eb4992?relay=wss%3A%2F%2Frelay.getalby.com%2Fv1&request_methods=get_info%20pay_invoice&name=App%20Name&icon=https%3A%2F%2Fexample.com%2Fimage.png&return_to=https%3A%2F%2Fexample.com&notification_types=payment_received%20payment_sent&max_amount=1000000&budget_renewal=monthly&expires_at=1740470142968&isolated=true&metadata=%7B%22message%22%3A%22hello%20world%22%7D`,
      );

      expect(nwaOptions.appPubkey).toEqual(
        "e73575d76c731102aefd4eb6fb0ddfaaf335eabe60255a22e6ca5e7074eb4992",
      );
      expect(nwaOptions.relayUrl).toEqual("wss://relay.getalby.com/v1");
      expect(nwaOptions.requestMethods).toEqual([
        "get_info",
        "pay_invoice",
      ] satisfies Nip47Method[]);
      expect(nwaOptions.notificationTypes).toEqual([
        "payment_received",
        "payment_sent",
      ] satisfies Nip47NotificationType[]);
      expect(nwaOptions.expiresAt).toBe(1740470142968);
      expect(nwaOptions.maxAmount).toBe(1000_000);
      expect(nwaOptions.budgetRenewal).toBe("monthly");
      expect(nwaOptions.isolated).toBe(true);
      expect(nwaOptions.metadata).toEqual({ message: "hello world" });
      expect(nwaOptions.name).toBe("App Name");
      expect(nwaOptions.icon).toBe("https://example.com/image.png");
      expect(nwaOptions.returnTo).toBe("https://example.com");
    });
  }

  test("incorrect scheme", () => {
    try {
      NWAClient.parseWalletAuthUrl("asd://");
      fail("should not pass");
    } catch (error) {
      expect("" + error).toBe(
        "Error: Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://",
      );
    }
  });
});



================================================
FILE: src/nwc/NWAClient.ts
================================================
import { bytesToHex, hexToBytes } from "@noble/hashes/utils";
import { generateSecretKey, getPublicKey, Relay } from "nostr-tools";
import {
  BudgetRenewalPeriod,
  Nip47Method,
  Nip47NetworkError,
  Nip47NotificationType,
} from "./types";
import { NWCClient } from "./NWCClient";
import { Subscription } from "nostr-tools/lib/types/abstract-relay";

export type NWAOptions = {
  relayUrl: string;
  appPubkey: string;
  requestMethods: Nip47Method[];

  name?: string;
  icon?: string;
  notificationTypes?: Nip47NotificationType[];
  maxAmount?: number;
  budgetRenewal?: BudgetRenewalPeriod;
  expiresAt?: number;
  isolated?: boolean;
  returnTo?: string;
  metadata?: unknown;
};

export type NewNWAClientOptions = Omit<NWAOptions, "appPubkey"> & {
  appSecretKey?: string;
};

export class NWAClient {
  options: NWAOptions;
  appSecretKey: string;
  relay: Relay;

  constructor(options: NewNWAClientOptions) {
    this.appSecretKey = options.appSecretKey || bytesToHex(generateSecretKey());
    this.options = {
      ...options,
      appPubkey: getPublicKey(hexToBytes(this.appSecretKey)),
    };

    if (!this.options.relayUrl) {
      throw new Error("Missing relay url");
    }
    if (!this.options.requestMethods) {
      throw new Error("Missing request methods");
    }
    this.relay = new Relay(this.options.relayUrl);

    if (globalThis.WebSocket === undefined) {
      console.error(
        "WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments",
      );
    }
  }

  /**
   * returns the NWA connection URI which should be given to the wallet
   */
  get connectionUri() {
    return this.getConnectionUri();
  }

  /**
   * returns the NWA connection URI which should be given to the wallet
   * @param nwaSchemeSuffix open a specific wallet. e.g. "alby" will set the scheme to
   * nostr+walletauth+alby to ensure the link will be opened in an Alby wallet
   */
  getConnectionUri(nwaSchemeSuffix = "") {
    const searchParams = new URLSearchParams({
      relay: this.options.relayUrl,
      request_methods: this.options.requestMethods.join(" "),
      ...(this.options.name ? { name: this.options.name } : {}),
      ...(this.options.icon ? { icon: this.options.icon } : {}),
      ...(this.options.returnTo ? { return_to: this.options.returnTo } : {}),
      ...(this.options.notificationTypes
        ? {
            notification_types: this.options.notificationTypes.join(" "),
          }
        : {}),
      ...(this.options.maxAmount
        ? { max_amount: this.options.maxAmount.toString() }
        : {}),
      ...(this.options.budgetRenewal
        ? { budget_renewal: this.options.budgetRenewal }
        : {}),
      ...(this.options.expiresAt
        ? { expires_at: this.options.expiresAt.toString() }
        : {}),
      ...(this.options.isolated
        ? { isolated: this.options.isolated.toString() }
        : {}),
      ...(this.options.metadata
        ? { metadata: JSON.stringify(this.options.metadata) }
        : {}),
    });

    return `nostr+walletauth${nwaSchemeSuffix ? `+${nwaSchemeSuffix}` : ""}://${this.options.appPubkey}?${searchParams
      .toString()
      .replace(/\+/g, "%20")}`;
  }

  static parseWalletAuthUrl(walletAuthUrl: string): NWAOptions {
    if (!walletAuthUrl.startsWith("nostr+walletauth")) {
      throw new Error(
        "Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://",
      );
    }
    // makes it possible to parse with URL in the different environments (browser/node/...)
    // parses with or without "//"
    const colonIndex = walletAuthUrl.indexOf(":");
    walletAuthUrl = walletAuthUrl.substring(colonIndex + 1);
    if (walletAuthUrl.startsWith("//")) {
      walletAuthUrl = walletAuthUrl.substring(2);
    }
    walletAuthUrl = "http://" + walletAuthUrl;

    const url = new URL(walletAuthUrl);

    const appPubkey = url.host;
    if (appPubkey?.length !== 64) {
      throw new Error("Incorrect app pubkey found in auth string");
    }

    const relayUrl = url.searchParams.get("relay");
    if (!relayUrl) {
      throw new Error("No relay URL found in auth string");
    }
    const requestMethods = url.searchParams
      .get("request_methods")
      ?.split(" ") as Nip47Method[] | undefined;
    if (!requestMethods?.length) {
      throw new Error("No request methods found in auth string");
    }

    const notificationTypes = url.searchParams
      .get("notification_types")
      ?.split(" ") as Nip47NotificationType[] | undefined;

    const maxAmountString = url.searchParams.get("max_amount");
    const expiresAtString = url.searchParams.get("expires_at");
    const metadataString = url.searchParams.get("metadata");

    return {
      name: url.searchParams.get("name") || undefined,
      icon: url.searchParams.get("icon") || undefined,
      returnTo: url.searchParams.get("return_to") || undefined,
      relayUrl,
      appPubkey,
      requestMethods,
      notificationTypes,
      budgetRenewal: url.searchParams.get("budget_renewal") as
        | BudgetRenewalPeriod
        | undefined,
      expiresAt: expiresAtString ? parseInt(expiresAtString) : undefined,
      maxAmount: maxAmountString ? parseInt(maxAmountString) : undefined,
      isolated: url.searchParams.get("isolated") === "true",
      metadata: metadataString ? JSON.parse(metadataString) : undefined,
    };
  }

  /**
   * Waits for a new app connection to be created via NWA (https://github.com/nostr-protocol/nips/pull/851)
   *
   * @returns a new NWCClient
   */
  async subscribe(args: {
    onSuccess: (nwcClient: NWCClient) => void;
  }): Promise<{
    unsub: () => void;
  }> {
    let subscribed = true;
    let endPromise: (() => void) | undefined;
    let onRelayDisconnect: (() => void) | undefined;
    let sub: Subscription | undefined;
    (async () => {
      while (subscribed) {
        try {
          await this._checkConnected();

          const sub = this.relay.subscribe(
            [
              {
                kinds: [13194], // NIP-47 info event
                "#p": [this.options.appPubkey],
              },
            ],
            {
              // eoseTimeout: 10000,
            },
          );
          console.info("subscribed to relay");

          const unsub = () => {
            sub.close();
            this.relay.close();
          };

          sub.onevent = async (event) => {
            const client = new NWCClient({
              relayUrl: this.options.relayUrl,
              secret: this.appSecretKey,
              walletPubkey: event.pubkey,
            });

            // try to fetch the lightning address
            try {
              const info = await client.getInfo();
              client.options.lud16 = info.lud16;
              client.lud16 = info.lud16;
            } catch (error) {
              console.error("failed to fetch get_info", error);
            }

            args.onSuccess(client);
            unsub();
          };

          await new Promise<void>((resolve) => {
            endPromise = () => {
              resolve();
            };
            onRelayDisconnect = () => {
              console.info("relay disconnected");
              endPromise?.();
            };
            this.relay.onclose = onRelayDisconnect;
          });
          if (onRelayDisconnect !== undefined) {
            this.relay.onclose = null;
          }
        } catch (error) {
          console.error(
            "error subscribing to info event",
            error || "unknown relay error",
          );
        }
        if (subscribed) {
          // wait a second and try re-connecting
          // any events during this period will be lost
          // unless using a relay that keeps events until client reconnect
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
      }
    })();

    return {
      unsub: () => {
        subscribed = false;
        endPromise?.();
        sub?.close();
      },
    };
  }

  private async _checkConnected() {
    if (!this.appSecretKey) {
      throw new Error("Missing secret key");
    }
    if (!this.options.relayUrl) {
      throw new Error("Missing relay url");
    }
    try {
      if (!this.relay.connected) {
        await this.relay.connect();
      }
    } catch (_ /* error is always undefined */) {
      console.error("failed to connect to relay", this.options.relayUrl);
      throw new Nip47NetworkError(
        "Failed to connect to " + this.options.relayUrl,
        "OTHER",
      );
    }
  }
}



================================================
FILE: src/nwc/NWCClient.test.ts
================================================
import "websocket-polyfill";
import { NWCClient } from "./NWCClient";

// this has no funds on it, I think ;-)
const exampleNwcUrl =
  "nostr+walletconnect://69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9?relay=wss://relay.getalby.com/v1&secret=e839faf78693765b3833027fefa5a305c78f6965d0a5d2e47a3fcb25aa7cc45b&lud16=hello@getalby.com";

describe("parseWalletConnectUrl", () => {
  test("standard protocol", () => {
    const parsed = NWCClient.parseWalletConnectUrl(exampleNwcUrl);
    expect(parsed.walletPubkey).toBe(
      "69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9",
    );
    expect(parsed.secret).toBe(
      "e839faf78693765b3833027fefa5a305c78f6965d0a5d2e47a3fcb25aa7cc45b",
    );
    expect(parsed.relayUrl).toBe("wss://relay.getalby.com/v1");
    expect(parsed.lud16).toBe("hello@getalby.com");
  });
  test("protocol without double slash", () => {
    const parsed = NWCClient.parseWalletConnectUrl(
      exampleNwcUrl.replace("nostr+walletconnect://", "nostr+walletconnect:"),
    );
    expect(parsed.walletPubkey).toBe(
      "69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9",
    );
    expect(parsed.secret).toBe(
      "e839faf78693765b3833027fefa5a305c78f6965d0a5d2e47a3fcb25aa7cc45b",
    );
    expect(parsed.relayUrl).toBe("wss://relay.getalby.com/v1");
  });
  test("legacy protocol without double slash", () => {
    const parsed = NWCClient.parseWalletConnectUrl(
      exampleNwcUrl.replace("nostr+walletconnect://", "nostrwalletconnect:"),
    );
    expect(parsed.walletPubkey).toBe(
      "69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9",
    );
    expect(parsed.secret).toBe(
      "e839faf78693765b3833027fefa5a305c78f6965d0a5d2e47a3fcb25aa7cc45b",
    );
    expect(parsed.relayUrl).toBe("wss://relay.getalby.com/v1");
  });
});

describe("NWCClient", () => {
  test("standard protocol", () => {
    const nwcClient = new NWCClient({ nostrWalletConnectUrl: exampleNwcUrl });
    expect(nwcClient.walletPubkey).toBe(
      "69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9",
    );
    expect(nwcClient.secret).toBe(
      "e839faf78693765b3833027fefa5a305c78f6965d0a5d2e47a3fcb25aa7cc45b",
    );
    expect(nwcClient.lud16).toBe("hello@getalby.com");
    expect(nwcClient.options.lud16).toBe("hello@getalby.com");
  });
});

describe("getAuthorizationUrl", () => {
  test("standard url", () => {
    const pubkey =
      "c5dc47856f533dad6c016b979ee3b21f83f88ae0f0058001b67a4b348339fe94";

    expect(
      NWCClient.getAuthorizationUrl(
        "https://nwc.getalby.com/apps/new",
        {
          budgetRenewal: "weekly",
          expiresAt: new Date("2023-07-21"),
          maxAmount: 100,
          name: "TestApp",
          returnTo: "https://example.com",
          requestMethods: ["pay_invoice", "get_balance"],
          notificationTypes: ["payment_received", "payment_sent"],
          isolated: true,
          metadata: { message: "hello world" },
        },
        pubkey,
      ).toString(),
    ).toEqual(
      `https://nwc.getalby.com/apps/new?name=TestApp&pubkey=${pubkey}&return_to=https%3A%2F%2Fexample.com&budget_renewal=weekly&expires_at=1689897600&max_amount=100&request_methods=pay_invoice+get_balance&notification_types=payment_received+payment_sent&isolated=true&metadata=%7B%22message%22%3A%22hello+world%22%7D`,
    );
  });

  test("hash router url is not supported", () => {
    const pubkey =
      "c5dc47856f533dad6c016b979ee3b21f83f88ae0f0058001b67a4b348339fe94";

    try {
      NWCClient.getAuthorizationUrl(
        "https://my.albyhub.com/#/apps/new",
        {},
        pubkey,
      );
      fail("error should have been thrown");
    } catch (error) {
      expect("" + error).toEqual("Error: hash router paths not supported");
    }
  });
});



================================================
FILE: src/nwc/NWCClient.ts
================================================
import {
  nip04,
  nip19,
  nip44,
  finalizeEvent,
  generateSecretKey,
  getEventHash,
  getPublicKey,
  Event,
  EventTemplate,
  Relay,
} from "nostr-tools";
import { hexToBytes, bytesToHex } from "@noble/hashes/utils";
import { Subscription } from "nostr-tools/lib/types/abstract-relay";
import {
  Nip47EncryptionType,
  Nip47NetworkError,
  Nip47SingleMethod,
  Nip47Method,
  Nip47Capability,
  Nip47GetInfoResponse,
  Nip47GetBudgetResponse,
  Nip47GetBalanceResponse,
  Nip47PayResponse,
  Nip47TimeoutValues,
  Nip47MultiPayInvoiceRequest,
  Nip47MultiPayKeysendRequest,
  Nip47MultiPayInvoiceResponse,
  Nip47MultiPayKeysendResponse,
  Nip47ListTransactionsRequest,
  Nip47ListTransactionsResponse,
  Nip47Transaction,
  Nip47NotificationType,
  Nip47Notification,
  Nip47PayInvoiceRequest,
  Nip47PayKeysendRequest,
  Nip47MakeInvoiceRequest,
  Nip47LookupInvoiceRequest,
  Nip47SignMessageRequest,
  Nip47CreateConnectionRequest,
  Nip47CreateConnectionResponse,
  Nip47SignMessageResponse,
  Nip47PublishError,
  Nip47PublishTimeoutError,
  Nip47ReplyTimeoutError,
  Nip47ResponseDecodingError,
  Nip47ResponseValidationError,
  Nip47UnexpectedResponseError,
  Nip47UnsupportedEncryptionError,
  Nip47WalletError,
  Nip47MultiMethod,
  NWCAuthorizationUrlOptions,
  Nip47MakeHoldInvoiceRequest,
  Nip47SettleHoldInvoiceRequest,
  Nip47SettleHoldInvoiceResponse,
  Nip47CancelHoldInvoiceRequest,
  Nip47CancelHoldInvoiceResponse,
} from "./types";

export interface NWCOptions {
  relayUrl: string;
  walletPubkey: string;
  secret?: string;
  lud16?: string;
}

export type NewNWCClientOptions = {
  relayUrl?: string;
  secret?: string;
  walletPubkey?: string;
  nostrWalletConnectUrl?: string;
  lud16?: string;
};

export class NWCClient {
  relay: Relay;
  relayUrl: string;
  secret: string | undefined;
  lud16: string | undefined;
  walletPubkey: string;
  options: NWCOptions;
  private _encryptionType: Nip47EncryptionType | undefined;

  static parseWalletConnectUrl(walletConnectUrl: string): NWCOptions {
    // makes it possible to parse with URL in the different environments (browser/node/...)
    // parses both new and legacy protocols, with or without "//"
    walletConnectUrl = walletConnectUrl
      .replace("nostrwalletconnect://", "http://")
      .replace("nostr+walletconnect://", "http://")
      .replace("nostrwalletconnect:", "http://")
      .replace("nostr+walletconnect:", "http://");
    const url = new URL(walletConnectUrl);
    const relayUrl = url.searchParams.get("relay");
    if (!relayUrl) {
      throw new Error("No relay URL found in connection string");
    }

    const options: NWCOptions = {
      walletPubkey: url.host,
      relayUrl,
    };
    const secret = url.searchParams.get("secret");
    if (secret) {
      options.secret = secret;
    }
    const lud16 = url.searchParams.get("lud16");
    if (lud16) {
      options.lud16 = lud16;
    }
    return options;
  }

  constructor(options?: NewNWCClientOptions) {
    if (options && options.nostrWalletConnectUrl) {
      options = {
        ...NWCClient.parseWalletConnectUrl(options.nostrWalletConnectUrl),
        ...options,
      };
    }
    this.options = {
      ...(options || {}),
    } as NWCOptions;

    this.relayUrl = this.options.relayUrl;
    this.relay = new Relay(this.relayUrl);
    if (this.options.secret) {
      this.secret = (
        this.options.secret.toLowerCase().startsWith("nsec")
          ? nip19.decode(this.options.secret).data
          : this.options.secret
      ) as string;
    }
    this.lud16 = this.options.lud16;
    this.walletPubkey = (
      this.options.walletPubkey.toLowerCase().startsWith("npub")
        ? nip19.decode(this.options.walletPubkey).data
        : this.options.walletPubkey
    ) as string;
    // this.subscribers = {};

    if (globalThis.WebSocket === undefined) {
      console.error(
        "WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments",
      );
    }
  }

  get nostrWalletConnectUrl() {
    return this.getNostrWalletConnectUrl();
  }

  getNostrWalletConnectUrl(includeSecret = true) {
    let url = `nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;
    if (includeSecret) {
      url = `${url}&secret=${this.secret}`;
    }
    return url;
  }

  get connected() {
    return this.relay.connected;
  }

  get publicKey() {
    if (!this.secret) {
      throw new Error("Missing secret key");
    }
    return getPublicKey(hexToBytes(this.secret));
  }

  get encryptionType(): string {
    if (!this._encryptionType) {
      throw new Error("Missing encryption or version");
    }
    return this._encryptionType;
  }

  getPublicKey(): Promise<string> {
    return Promise.resolve(this.publicKey);
  }

  signEvent(event: EventTemplate): Promise<Event> {
    if (!this.secret) {
      throw new Error("Missing secret key");
    }

    return Promise.resolve(finalizeEvent(event, hexToBytes(this.secret)));
  }

  getEventHash(event: Event) {
    return getEventHash(event);
  }

  close() {
    return this.relay.close();
  }

  async encrypt(pubkey: string, content: string) {
    if (!this.secret) {
      throw new Error("Missing secret");
    }
    let encrypted;
    if (this.encryptionType === "nip04") {
      encrypted = await nip04.encrypt(this.secret, pubkey, content);
    } else {
      const key = nip44.getConversationKey(hexToBytes(this.secret), pubkey);
      encrypted = nip44.encrypt(content, key);
    }
    return encrypted;
  }

  async decrypt(pubkey: string, content: string) {
    if (!this.secret) {
      throw new Error("Missing secret");
    }
    let decrypted;
    if (this.encryptionType === "nip04") {
      decrypted = await nip04.decrypt(this.secret, pubkey, content);
    } else {
      const key = nip44.getConversationKey(hexToBytes(this.secret), pubkey);
      decrypted = nip44.decrypt(content, key);
    }
    return decrypted;
  }

  static getAuthorizationUrl(
    authorizationBasePath: string,
    options: NWCAuthorizationUrlOptions = {},
    pubkey: string,
  ): URL {
    if (authorizationBasePath.indexOf("/#/") > -1) {
      throw new Error("hash router paths not supported");
    }
    const url = new URL(authorizationBasePath);
    if (options.name) {
      url.searchParams.set("name", options.name);
    }
    url.searchParams.set("pubkey", pubkey);
    if (options.returnTo) {
      url.searchParams.set("return_to", options.returnTo);
    }

    if (options.budgetRenewal) {
      url.searchParams.set("budget_renewal", options.budgetRenewal);
    }
    if (options.expiresAt) {
      url.searchParams.set(
        "expires_at",
        Math.floor(options.expiresAt.getTime() / 1000).toString(),
      );
    }
    if (options.maxAmount) {
      url.searchParams.set("max_amount", options.maxAmount.toString());
    }

    if (options.requestMethods) {
      url.searchParams.set("request_methods", options.requestMethods.join(" "));
    }
    if (options.notificationTypes) {
      url.searchParams.set(
        "notification_types",
        options.notificationTypes.join(" "),
      );
    }

    if (options.isolated) {
      url.searchParams.set("isolated", "true");
    }

    if (options.metadata) {
      url.searchParams.set("metadata", JSON.stringify(options.metadata));
    }

    return url;
  }

  /**
   * create a new client-initiated NWC connection via HTTP deeplink
   *
   * @param authorizationBasePath the deeplink path e.g. https://my.albyhub.com/apps/new
   * @param options configure the created app (e.g. the name, budget, expiration)
   * @param secret optionally pass a secret, otherwise one will be generated.
   */
  static fromAuthorizationUrl(
    authorizationBasePath: string,
    options: NWCAuthorizationUrlOptions = {},
    secret?: string,
  ): Promise<NWCClient> {
    secret = secret || bytesToHex(generateSecretKey());

    // here we assume an browser context and window/document is available
    // we set the location.host as a default name if none is given
    if (!options.name) {
      options.name = document.location.host;
    }
    const url = this.getAuthorizationUrl(
      authorizationBasePath,
      options,
      getPublicKey(hexToBytes(secret)),
    );
    const height = 600;
    const width = 400;
    const top = window.outerHeight / 2 + window.screenY - height / 2;
    const left = window.outerWidth / 2 + window.screenX - width / 2;

    return new Promise((resolve, reject) => {
      const popup = window.open(
        url.toString(),
        `${document.title} - Wallet Connect`,
        `height=${height},width=${width},top=${top},left=${left}`,
      );
      if (!popup) {
        reject(new Error("failed to execute window.open"));
        return;
      }

      const checkForPopup = () => {
        if (popup && popup.closed) {
          clearInterval(popupChecker);
          window.removeEventListener("message", onMessage);
          reject(new Error("Popup closed"));
        }
      };

      const onMessage = (message: {
        data?: {
          type: "nwc:success" | unknown;
          relayUrl?: string;
          walletPubkey?: string;
          lud16?: string;
        };
        origin: string;
      }) => {
        const data = message.data;
        if (
          data &&
          data.type === "nwc:success" &&
          message.origin === `${url.protocol}//${url.host}`
        ) {
          if (!data.relayUrl) {
            reject(new Error("no relayUrl in response"));
          }
          if (!data.walletPubkey) {
            reject(new Error("no walletPubkey in response"));
          }
          resolve(
            new NWCClient({
              relayUrl: data.relayUrl,
              walletPubkey: data.walletPubkey,
              secret,
              lud16: data.lud16,
            }),
          );
          clearInterval(popupChecker);
          window.removeEventListener("message", onMessage);
          if (popup) {
            popup.close(); // close the popup
          }
        }
      };
      const popupChecker = setInterval(checkForPopup, 500);
      window.addEventListener("message", onMessage);
    });
  }

  async getWalletServiceInfo(): Promise<{
    encryptions: string[];
    capabilities: Nip47Capability[];
    notifications: Nip47NotificationType[];
  }> {
    await this._checkConnected();
    const events = await new Promise<Event[]>((resolve, reject) => {
      const events: Event[] = [];
      const sub = this.relay.subscribe(
        [
          {
            kinds: [13194],
            limit: 1,
            authors: [this.walletPubkey],
          },
        ],
        {
          eoseTimeout: 10000,
        },
      );

      sub.onevent = (event) => {
        events.push(event);
      };

      sub.oneose = () => {
        sub.close();
        resolve(events);
      };
    });

    if (!events.length) {
      throw new Error("no info event (kind 13194) returned from relay");
    }
    const content = events[0].content;
    const notificationsTag = events[0].tags.find(
      (t) => t[0] === "notifications",
    );
    // TODO: Remove version tag after 01-06-2025
    const versionsTag = events[0].tags.find((t) => t[0] === "v");
    const encryptionTag = events[0].tags.find((t) => t[0] === "encryption");

    let encryptions: string[] = ["nip04" satisfies Nip47EncryptionType];
    // TODO: Remove version tag after 01-06-2025
    if (versionsTag && versionsTag[1].includes("1.0")) {
      encryptions.push("nip44_v2" satisfies Nip47EncryptionType);
    }
    if (encryptionTag) {
      encryptions = encryptionTag[1].split(" ") as Nip47EncryptionType[];
    }
    return {
      encryptions,
      // delimiter is " " per spec, but Alby NWC originally returned ","
      capabilities: content.split(/[ |,]/g) as Nip47Method[],
      notifications: (notificationsTag?.[1]?.split(" ") ||
        []) as Nip47NotificationType[],
    };
  }

  async getInfo(): Promise<Nip47GetInfoResponse> {
    try {
      const result = await this.executeNip47Request<Nip47GetInfoResponse>(
        "get_info",
        {},
        (result) => !!result.methods,
        { replyTimeout: 10000 },
      );
      return result;
    } catch (error) {
      console.error("Failed to request get_info", error);
      throw error;
    }
  }

  async getBudget(): Promise<Nip47GetBudgetResponse> {
    try {
      const result = await this.executeNip47Request<Nip47GetBudgetResponse>(
        "get_budget",
        {},
        (result) => result !== undefined,
        { replyTimeout: 10000 },
      );
      return result;
    } catch (error) {
      console.error("Failed to request get_budget", error);
      throw error;
    }
  }

  async getBalance(): Promise<Nip47GetBalanceResponse> {
    try {
      const result = await this.executeNip47Request<Nip47GetBalanceResponse>(
        "get_balance",
        {},
        (result) => result.balance !== undefined,
        { replyTimeout: 10000 },
      );
      return result;
    } catch (error) {
      console.error("Failed to request get_balance", error);
      throw error;
    }
  }

  async payInvoice(request: Nip47PayInvoiceRequest): Promise<Nip47PayResponse> {
    try {
      const result = await this.executeNip47Request<Nip47PayResponse>(
        "pay_invoice",
        request,
        (result) => !!result.preimage,
      );
      return result;
    } catch (error) {
      console.error("Failed to request pay_invoice", error);
      throw error;
    }
  }

  async payKeysend(request: Nip47PayKeysendRequest): Promise<Nip47PayResponse> {
    try {
      const result = await this.executeNip47Request<Nip47PayResponse>(
        "pay_keysend",
        request,
        (result) => !!result.preimage,
      );

      return result;
    } catch (error) {
      console.error("Failed to request pay_keysend", error);
      throw error;
    }
  }

  async signMessage(
    request: Nip47SignMessageRequest,
  ): Promise<Nip47SignMessageResponse> {
    try {
      const result = await this.executeNip47Request<Nip47SignMessageResponse>(
        "sign_message",
        request,
        (result) => result.message === request.message && !!result.signature,
      );

      return result;
    } catch (error) {
      console.error("Failed to request sign_message", error);
      throw error;
    }
  }

  async createConnection(
    request: Nip47CreateConnectionRequest,
  ): Promise<Nip47CreateConnectionResponse> {
    try {
      const result =
        await this.executeNip47Request<Nip47CreateConnectionResponse>(
          "create_connection",
          request,
          (result) => !!result.wallet_pubkey,
        );

      return result;
    } catch (error) {
      console.error("Failed to request create_connection", error);
      throw error;
    }
  }

  async multiPayInvoice(
    request: Nip47MultiPayInvoiceRequest,
  ): Promise<Nip47MultiPayInvoiceResponse> {
    try {
      const results = await this.executeMultiNip47Request<
        { invoice: Nip47PayInvoiceRequest } & Nip47PayResponse
      >(
        "multi_pay_invoice",
        request,
        request.invoices.length,
        (result) => !!result.preimage,
      );

      return {
        invoices: results,
        // TODO: error handling
        errors: [],
      };
    } catch (error) {
      console.error("Failed to request multi_pay_invoice", error);
      throw error;
    }
  }

  async multiPayKeysend(
    request: Nip47MultiPayKeysendRequest,
  ): Promise<Nip47MultiPayKeysendResponse> {
    try {
      const results = await this.executeMultiNip47Request<
        { keysend: Nip47PayKeysendRequest } & Nip47PayResponse
      >(
        "multi_pay_keysend",
        request,
        request.keysends.length,
        (result) => !!result.preimage,
      );

      return {
        keysends: results,
        // TODO: error handling
        errors: [],
      };
    } catch (error) {
      console.error("Failed to request multi_pay_keysend", error);
      throw error;
    }
  }

  async makeInvoice(
    request: Nip47MakeInvoiceRequest,
  ): Promise<Nip47Transaction> {
    try {
      if (!request.amount) {
        throw new Error("No amount specified");
      }

      const result = await this.executeNip47Request<Nip47Transaction>(
        "make_invoice",
        request,
        (result) => !!result.invoice,
      );

      return result;
    } catch (error) {
      console.error("Failed to request make_invoice", error);
      throw error;
    }
  }

  async makeHoldInvoice(
    request: Nip47MakeHoldInvoiceRequest,
  ): Promise<Nip47Transaction> {
    try {
      if (!request.amount) {
        throw new Error("No amount specified");
      }
      if (!request.payment_hash) {
        throw new Error("No payment hash specified");
      }

      const result = await this.executeNip47Request<Nip47Transaction>(
        "make_hold_invoice",
        request,
        (result) => !!result.invoice,
      );

      return result;
    } catch (error) {
      console.error("Failed to request make_hold_invoice", error);
      throw error;
    }
  }

  async settleHoldInvoice(
    request: Nip47SettleHoldInvoiceRequest,
  ): Promise<Nip47SettleHoldInvoiceResponse> {
    try {
      const result = await this.executeNip47Request<Nip47Transaction>(
        "settle_hold_invoice",
        request,
        (result) => !!result,
      );

      return result;
    } catch (error) {
      console.error("Failed to request settle_hold_invoice", error);
      throw error;
    }
  }

  async cancelHoldInvoice(
    request: Nip47CancelHoldInvoiceRequest,
  ): Promise<Nip47CancelHoldInvoiceResponse> {
    try {
      const result = await this.executeNip47Request<Nip47Transaction>(
        "cancel_hold_invoice",
        request,
        (result) => !!result,
      );

      return result;
    } catch (error) {
      console.error("Failed to request cancel_hold_invoice", error);
      throw error;
    }
  }

  async lookupInvoice(
    request: Nip47LookupInvoiceRequest,
  ): Promise<Nip47Transaction> {
    try {
      const result = await this.executeNip47Request<Nip47Transaction>(
        "lookup_invoice",
        request,
        (result) => !!result.invoice,
      );

      return result;
    } catch (error) {
      console.error("Failed to request lookup_invoice", error);
      throw error;
    }
  }

  async listTransactions(
    request: Nip47ListTransactionsRequest,
  ): Promise<Nip47ListTransactionsResponse> {
    try {
      // maybe we can tailor the response to our needs
      const result =
        await this.executeNip47Request<Nip47ListTransactionsResponse>(
          "list_transactions",
          request,
          (response) => !!response.transactions,
          { replyTimeout: 10000 },
        );

      return result;
    } catch (error) {
      console.error("Failed to request list_transactions", error);
      throw error;
    }
  }

  async subscribeNotifications(
    onNotification: (notification: Nip47Notification) => void,
    notificationTypes?: Nip47NotificationType[],
  ): Promise<() => void> {
    let subscribed = true;
    let endPromise: (() => void) | undefined;
    let onRelayDisconnect: (() => void) | undefined;
    let sub: Subscription | undefined;
    (async () => {
      while (subscribed) {
        try {
          await this._checkConnected();
          await this._selectEncryptionType();
          sub = this.relay.subscribe(
            [
              {
                kinds: [
                  ...(this.encryptionType === "nip04" ? [23196] : [23197]),
                ],
                authors: [this.walletPubkey],
                "#p": [this.publicKey],
              },
            ],
            {},
          );
          console.info("subscribed to relay");

          sub.onevent = async (event) => {
            const decryptedContent = await this.decrypt(
              this.walletPubkey,
              event.content,
            );
            let notification;
            try {
              notification = JSON.parse(decryptedContent) as Nip47Notification;
            } catch (e) {
              console.error("Failed to parse decrypted event content", e);
              return;
            }
            if (notification.notification) {
              if (
                !notificationTypes ||
                notificationTypes.indexOf(notification.notification_type) > -1
              ) {
                onNotification(notification);
              }
            } else {
              console.error("No notification in response", notification);
            }
          };

          await new Promise<void>((resolve) => {
            endPromise = () => {
              resolve();
            };
            onRelayDisconnect = () => {
              console.info("relay disconnected");
              endPromise?.();
            };
            this.relay.onclose = onRelayDisconnect;
          });
          if (onRelayDisconnect !== undefined) {
            this.relay.onclose = null;
          }
        } catch (error) {
          console.error(
            "error subscribing to notifications",
            error || "unknown relay error",
          );
        }
        if (subscribed) {
          // wait a second and try re-connecting
          // any notifications during this period will be lost
          // unless using a relay that keeps events until client reconnect
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
      }
    })();

    return () => {
      subscribed = false;
      endPromise?.();
      sub?.close();
    };
  }

  private async executeNip47Request<T>(
    nip47Method: Nip47SingleMethod,
    params: unknown,
    resultValidator: (result: T) => boolean,
    timeoutValues?: Nip47TimeoutValues,
  ): Promise<T> {
    await this._checkConnected();
    await this._selectEncryptionType();

    return new Promise<T>((resolve, reject) => {
      (async () => {
        const command = {
          method: nip47Method,
          params,
        };
        const encryptedCommand = await this.encrypt(
          this.walletPubkey,
          JSON.stringify(command),
        );
        const eventTemplate: EventTemplate = {
          kind: 23194,
          created_at: Math.floor(Date.now() / 1000),
          tags: [
            ["p", this.walletPubkey],
            // TODO: Remove version tag after 01-06-2025
            ["v", this.encryptionType === "nip44_v2" ? "1.0" : "0.0"],
            ["encryption", this.encryptionType],
          ],
          content: encryptedCommand,
        };

        const event = await this.signEvent(eventTemplate);
        // subscribe to NIP_47_SUCCESS_RESPONSE_KIND and NIP_47_ERROR_RESPONSE_KIND
        // that reference the request event (NIP_47_REQUEST_KIND)
        const sub = this.relay.subscribe(
          [
            {
              kinds: [23195],
              authors: [this.walletPubkey],
              "#e": [event.id],
            },
          ],
          {},
        );

        function replyTimeout() {
          sub.close();
          //console.error(`Reply timeout: event ${event.id} `);
          reject(
            new Nip47ReplyTimeoutError(
              `reply timeout: event ${event.id}`,
              "INTERNAL",
            ),
          );
        }

        const replyTimeoutCheck = setTimeout(
          replyTimeout,
          timeoutValues?.replyTimeout || 60000,
        );

        sub.onevent = async (event) => {
          // console.log(`Received reply event: `, event);
          clearTimeout(replyTimeoutCheck);
          sub.close();
          const decryptedContent = await this.decrypt(
            this.walletPubkey,
            event.content,
          );
          // console.log(`Decrypted content: `, decryptedContent);
          let response;
          try {
            response = JSON.parse(decryptedContent);
          } catch (e) {
            clearTimeout(replyTimeoutCheck);
            sub.close();
            reject(
              new Nip47ResponseDecodingError(
                "failed to deserialize response",
                "INTERNAL",
              ),
            );
            return;
          }
          if (response.result) {
            // console.info("NIP-47 result", response.result);
            if (resultValidator(response.result)) {
              resolve(response.result);
            } else {
              clearTimeout(replyTimeoutCheck);
              sub.close();
              reject(
                new Nip47ResponseValidationError(
                  "response from NWC failed validation: " +
                    JSON.stringify(response.result),
                  "INTERNAL",
                ),
              );
            }
          } else {
            clearTimeout(replyTimeoutCheck);
            sub.close();
            // console.error("Wallet error", response.error);
            reject(
              new Nip47WalletError(
                response.error?.message || "unknown Error",
                response.error?.code || "INTERNAL",
              ),
            );
          }
        };

        function publishTimeout() {
          sub.close();
          //console.error(`Publish timeout: event ${event.id}`);
          reject(
            new Nip47PublishTimeoutError(
              `publish timeout: ${event.id}`,
              "INTERNAL",
            ),
          );
        }
        const publishTimeoutCheck = setTimeout(
          publishTimeout,
          timeoutValues?.publishTimeout || 5000,
        );

        try {
          await this.relay.publish(event);
          clearTimeout(publishTimeoutCheck);
          //console.debug(`Event ${event.id} for ${invoice} published`);
        } catch (error) {
          //console.error(`Failed to publish to ${this.relay.url}`, error);
          clearTimeout(publishTimeoutCheck);
          reject(
            new Nip47PublishError(`failed to publish: ${error}`, "INTERNAL"),
          );
        }
      })();
    });
  }

  // TODO: this method currently fails if any payment fails.
  // this could be improved in the future.
  // TODO: reduce duplication between executeNip47Request and executeMultiNip47Request
  private async executeMultiNip47Request<T>(
    nip47Method: Nip47MultiMethod,
    params: unknown,
    numPayments: number,
    resultValidator: (result: T) => boolean,
    timeoutValues?: Nip47TimeoutValues,
  ): Promise<(T & { dTag: string })[]> {
    await this._checkConnected();
    await this._selectEncryptionType();
    const results: (T & { dTag: string })[] = [];
    return new Promise<(T & { dTag: string })[]>((resolve, reject) => {
      (async () => {
        const command = {
          method: nip47Method,
          params,
        };
        const encryptedCommand = await this.encrypt(
          this.walletPubkey,
          JSON.stringify(command),
        );
        const eventTemplate: EventTemplate = {
          kind: 23194,
          created_at: Math.floor(Date.now() / 1000),
          tags: [
            ["p", this.walletPubkey],
            // TODO: Remove version tag after 01-06-2025
            ["v", this.encryptionType === "nip44_v2" ? "1.0" : "0.0"],
            ["encryption", this.encryptionType],
          ],
          content: encryptedCommand,
        };

        const event = await this.signEvent(eventTemplate);
        // subscribe to NIP_47_SUCCESS_RESPONSE_KIND and NIP_47_ERROR_RESPONSE_KIND
        // that reference the request event (NIP_47_REQUEST_KIND)
        const sub = this.relay.subscribe(
          [
            {
              kinds: [23195],
              authors: [this.walletPubkey],
              "#e": [event.id],
            },
          ],
          {},
        );

        function replyTimeout() {
          sub.close();
          //console.error(`Reply timeout: event ${event.id} `);
          reject(
            new Nip47ReplyTimeoutError(
              `reply timeout: event ${event.id}`,
              "INTERNAL",
            ),
          );
        }

        const replyTimeoutCheck = setTimeout(
          replyTimeout,
          timeoutValues?.replyTimeout || 60000,
        );

        sub.onevent = async (event) => {
          // console.log(`Received reply event: `, event);

          const decryptedContent = await this.decrypt(
            this.walletPubkey,
            event.content,
          );
          // console.log(`Decrypted content: `, decryptedContent);
          let response;
          try {
            response = JSON.parse(decryptedContent);
          } catch (e) {
            // console.error(e);
            clearTimeout(replyTimeoutCheck);
            sub.close();
            reject(
              new Nip47ResponseDecodingError(
                "failed to deserialize response",
                "INTERNAL",
              ),
            );
          }
          if (response.result) {
            // console.info("NIP-47 result", response.result);
            if (!resultValidator(response.result)) {
              clearTimeout(replyTimeoutCheck);
              sub.close();
              reject(
                new Nip47ResponseValidationError(
                  "Response from NWC failed validation: " +
                    JSON.stringify(response.result),
                  "INTERNAL",
                ),
              );
              return;
            }
            const dTag = event.tags.find((tag) => tag[0] === "d")?.[1];
            if (dTag === undefined) {
              clearTimeout(replyTimeoutCheck);
              sub.close();
              reject(
                new Nip47ResponseValidationError(
                  "No d tag found in response event",
                  "INTERNAL",
                ),
              );
              return;
            }
            results.push({
              ...response.result,
              dTag,
            });
            if (results.length === numPayments) {
              clearTimeout(replyTimeoutCheck);
              sub.close();
              //console.log("Received results", results);
              resolve(results);
            }
          } else {
            clearTimeout(replyTimeoutCheck);
            sub.close();
            reject(
              new Nip47UnexpectedResponseError(
                response.error?.message,
                response.error?.code,
              ),
            );
          }
        };

        function publishTimeout() {
          sub.close();
          //console.error(`Publish timeout: event ${event.id}`);
          reject(
            new Nip47PublishTimeoutError(
              `Publish timeout: ${event.id}`,
              "INTERNAL",
            ),
          );
        }
        const publishTimeoutCheck = setTimeout(
          publishTimeout,
          timeoutValues?.publishTimeout || 5000,
        );

        try {
          await this.relay.publish(event);
          clearTimeout(publishTimeoutCheck);
          //console.debug(`Event ${event.id} for ${invoice} published`);
        } catch (error) {
          //console.error(`Failed to publish to ${this.relay.url}`, error);
          clearTimeout(publishTimeoutCheck);
          reject(
            new Nip47PublishError(`Failed to publish: ${error}`, "INTERNAL"),
          );
        }
      })();
    });
  }

  private async _checkConnected() {
    if (!this.secret) {
      throw new Error("Missing secret key");
    }
    if (!this.relayUrl) {
      throw new Error("Missing relay url");
    }
    try {
      if (!this.relay.connected) {
        await this.relay.connect();
      }
    } catch (_ /* error is always undefined */) {
      console.error("failed to connect to relay", this.relayUrl);
      throw new Nip47NetworkError(
        "Failed to connect to " + this.relayUrl,
        "OTHER",
      );
    }
  }

  private async _selectEncryptionType() {
    if (!this._encryptionType) {
      const walletServiceInfo = await this.getWalletServiceInfo();
      const encryptionType = this._findPreferredEncryptionType(
        walletServiceInfo.encryptions,
      );
      if (!encryptionType) {
        throw new Nip47UnsupportedEncryptionError(
          `no compatible encryption or version found between wallet and client`,
          "UNSUPPORTED_ENCRYPTION",
        );
      }
      if (encryptionType === "nip04") {
        console.warn(
          "NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead.",
        );
      }
      this._encryptionType = encryptionType;
    }
  }

  private _findPreferredEncryptionType(
    encryptions: string[],
  ): Nip47EncryptionType | null {
    if (encryptions.includes("nip44_v2")) {
      return "nip44_v2";
    }
    if (encryptions.includes("nip04")) {
      return "nip04";
    }
    return null;
  }
}



================================================
FILE: src/nwc/NWCWalletService.ts
================================================
import {
  nip04,
  nip44,
  finalizeEvent,
  getPublicKey,
  Event,
  EventTemplate,
  Relay,
} from "nostr-tools";
import { hexToBytes } from "@noble/hashes/utils";
import { Subscription } from "nostr-tools/lib/types/abstract-relay";

import {
  Nip47MakeInvoiceRequest,
  Nip47Method,
  Nip47NetworkError,
  Nip47NotificationType,
  Nip47PayInvoiceRequest,
  Nip47PayKeysendRequest,
  Nip47LookupInvoiceRequest,
  Nip47ListTransactionsRequest,
  Nip47SignMessageRequest,
  Nip47SingleMethod,
  Nip47EncryptionType,
} from "./types";
import {
  NWCWalletServiceRequestHandler,
  NWCWalletServiceResponse,
  NWCWalletServiceResponsePromise,
} from "./NWCWalletServiceRequestHandler";

export type NewNWCWalletServiceOptions = {
  relayUrl: string;
};

export class NWCWalletServiceKeyPair {
  walletSecret: string;
  walletPubkey: string;
  clientPubkey: string;
  constructor(walletSecret: string, clientPubkey: string) {
    this.walletSecret = walletSecret;
    this.clientPubkey = clientPubkey;
    if (!this.walletSecret) {
      throw new Error("Missing wallet secret key");
    }
    if (!this.clientPubkey) {
      throw new Error("Missing client pubkey");
    }
    this.walletPubkey = getPublicKey(hexToBytes(this.walletSecret));
  }
}

export class NWCWalletService {
  relay: Relay;
  relayUrl: string;

  constructor(options: NewNWCWalletServiceOptions) {
    this.relayUrl = options.relayUrl;

    this.relay = new Relay(this.relayUrl);

    if (globalThis.WebSocket === undefined) {
      console.error(
        "WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments",
      );
    }
  }

  async publishWalletServiceInfoEvent(
    walletSecret: string,
    supportedMethods: Nip47SingleMethod[],
    supportedNotifications: Nip47NotificationType[],
  ) {
    try {
      await this._checkConnected();
      const eventTemplate: EventTemplate = {
        kind: 13194,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
          ["encryption", "nip04 nip44_v2"],
          ["notifications", supportedNotifications.join(" ")],
        ],
        content: supportedMethods.join(" "),
      };

      const event = await this.signEvent(eventTemplate, walletSecret);
      await this.relay.publish(event);
    } catch (error) {
      console.error("failed to publish wallet service info event", error);
      throw error;
    }
  }

  async subscribe(
    keypair: NWCWalletServiceKeyPair,
    handler: NWCWalletServiceRequestHandler,
  ): Promise<() => void> {
    let subscribed = true;
    let endPromise: (() => void) | undefined;
    let onRelayDisconnect: (() => void) | undefined;
    let sub: Subscription | undefined;
    (async () => {
      while (subscribed) {
        try {
          console.info("checking connection to relay");
          await this._checkConnected();
          console.info("subscribing to relay");
          sub = this.relay.subscribe(
            [
              {
                kinds: [23194],
                authors: [keypair.clientPubkey],
                "#p": [keypair.walletPubkey],
              },
            ],
            {},
          );
          console.info("subscribed to relay");

          sub.onevent = async (event) => {
            try {
              // console.info("Got event", event);
              const encryptionType = (event.tags.find(
                (t) => t[0] === "encryption",
              )?.[1] || "nip04") as Nip47EncryptionType;

              const decryptedContent = await this.decrypt(
                keypair,
                event.content,
                encryptionType,
              );
              const request = JSON.parse(decryptedContent) as {
                method: Nip47Method;
                params: unknown;
              };

              let responsePromise:
                | NWCWalletServiceResponsePromise<unknown>
                | undefined;

              switch (request.method) {
                case "get_info":
                  responsePromise = handler.getInfo?.();
                  break;
                case "make_invoice":
                  responsePromise = handler.makeInvoice?.(
                    request.params as Nip47MakeInvoiceRequest,
                  );
                  break;
                case "pay_invoice":
                  responsePromise = handler.payInvoice?.(
                    request.params as Nip47PayInvoiceRequest,
                  );
                  break;
                case "pay_keysend":
                  responsePromise = handler.payKeysend?.(
                    request.params as Nip47PayKeysendRequest,
                  );
                  break;
                case "get_balance":
                  responsePromise = handler.getBalance?.();
                  break;
                case "lookup_invoice":
                  responsePromise = handler.lookupInvoice?.(
                    request.params as Nip47LookupInvoiceRequest,
                  );
                  break;
                case "list_transactions":
                  responsePromise = handler.listTransactions?.(
                    request.params as Nip47ListTransactionsRequest,
                  );
                  break;
                case "sign_message":
                  responsePromise = handler.signMessage?.(
                    request.params as Nip47SignMessageRequest,
                  );
                  break;
                // TODO: handle multi_* methods
              }

              let response: NWCWalletServiceResponse<unknown> | undefined =
                await responsePromise;

              if (!response) {
                console.warn("received unsupported method", request.method);
                response = {
                  error: {
                    code: "NOT_IMPLEMENTED",
                    message:
                      "This method is not supported by the wallet service",
                  },
                  result: undefined,
                };
              }

              const responseEventTemplate: EventTemplate = {
                kind: 23195,
                created_at: Math.floor(Date.now() / 1000),
                tags: [["e", event.id]],
                content: await this.encrypt(
                  keypair,
                  JSON.stringify({
                    result_type: request.method,
                    ...response,
                  }),
                  encryptionType,
                ),
              };

              const responseEvent = await this.signEvent(
                responseEventTemplate,
                keypair.walletSecret,
              );
              await this.relay.publish(responseEvent);
            } catch (e) {
              console.error("Failed to parse decrypted event content", e);
              return;
            }
          };

          await new Promise<void>((resolve) => {
            endPromise = () => {
              resolve();
            };
            onRelayDisconnect = () => {
              console.error("relay disconnected");
              endPromise?.();
            };
            this.relay.onclose = onRelayDisconnect;
          });
          if (onRelayDisconnect !== undefined) {
            this.relay.onclose = null;
          }
        } catch (error) {
          console.error(
            "error subscribing to requests",
            error || "unknown relay error",
          );
        }
        if (subscribed) {
          // wait a second and try re-connecting
          // any notifications during this period will be lost
          // unless using a relay that keeps events until client reconnect
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
      }
    })();

    return () => {
      subscribed = false;
      endPromise?.();
      sub?.close();
    };
  }

  get connected() {
    return this.relay.connected;
  }

  signEvent(event: EventTemplate, secretKey: string): Promise<Event> {
    return Promise.resolve(finalizeEvent(event, hexToBytes(secretKey)));
  }

  close() {
    return this.relay.close();
  }

  async encrypt(
    keypair: NWCWalletServiceKeyPair,
    content: string,
    encryptionType: Nip47EncryptionType,
  ) {
    let encrypted;
    // console.info("encrypting with" + encryptionType);
    if (encryptionType === "nip04") {
      encrypted = await nip04.encrypt(
        keypair.walletSecret,
        keypair.clientPubkey,
        content,
      );
    } else {
      const key = nip44.getConversationKey(
        hexToBytes(keypair.walletSecret),
        keypair.clientPubkey,
      );
      encrypted = nip44.encrypt(content, key);
    }
    return encrypted;
  }

  async decrypt(
    keypair: NWCWalletServiceKeyPair,
    content: string,
    encryptionType: Nip47EncryptionType,
  ) {
    let decrypted;
    // console.info("decrypting with" + encryptionType);
    if (encryptionType === "nip04") {
      decrypted = await nip04.decrypt(
        keypair.walletSecret,
        keypair.clientPubkey,
        content,
      );
    } else {
      const key = nip44.getConversationKey(
        hexToBytes(keypair.walletSecret),
        keypair.clientPubkey,
      );
      decrypted = nip44.decrypt(content, key);
    }
    return decrypted;
  }

  private async _checkConnected() {
    if (!this.relayUrl) {
      throw new Error("Missing relay url");
    }
    try {
      if (!this.relay.connected) {
        await this.relay.connect();
      }
    } catch (_ /* error is always undefined */) {
      console.error("failed to connect to relay", this.relayUrl);
      throw new Nip47NetworkError(
        "Failed to connect to " + this.relayUrl,
        "OTHER",
      );
    }
  }
}



================================================
FILE: src/nwc/NWCWalletServiceRequestHandler.ts
================================================
import type {
  Nip47GetBalanceResponse,
  Nip47GetInfoResponse,
  Nip47ListTransactionsRequest,
  Nip47ListTransactionsResponse,
  Nip47LookupInvoiceRequest,
  Nip47MakeInvoiceRequest,
  Nip47PayInvoiceRequest,
  Nip47PayKeysendRequest,
  Nip47PayResponse,
  Nip47SignMessageRequest,
  Nip47SignMessageResponse,
  Nip47Transaction,
} from "./types";
export type NWCWalletServiceRequestHandlerError =
  | {
      code: string;
      message: string;
    }
  | undefined;

export type NWCWalletServiceResponse<T> = {
  result: T | undefined;
  error: NWCWalletServiceRequestHandlerError;
};
export type NWCWalletServiceResponsePromise<T> = Promise<{
  result: T | undefined;
  error: NWCWalletServiceRequestHandlerError;
}>;

export interface NWCWalletServiceRequestHandler {
  getInfo?(): NWCWalletServiceResponsePromise<Nip47GetInfoResponse>;
  makeInvoice?(
    request: Nip47MakeInvoiceRequest,
  ): NWCWalletServiceResponsePromise<Nip47Transaction>;
  payInvoice?(
    request: Nip47PayInvoiceRequest,
  ): NWCWalletServiceResponsePromise<Nip47PayResponse>;
  payKeysend?(
    request: Nip47PayKeysendRequest,
  ): NWCWalletServiceResponsePromise<Nip47Transaction>;
  getBalance?(): NWCWalletServiceResponsePromise<Nip47GetBalanceResponse>;
  lookupInvoice?(
    request: Nip47LookupInvoiceRequest,
  ): NWCWalletServiceResponsePromise<Nip47Transaction>;
  listTransactions?(
    request: Nip47ListTransactionsRequest,
  ): NWCWalletServiceResponsePromise<Nip47ListTransactionsResponse>;
  signMessage?(
    request: Nip47SignMessageRequest,
  ): NWCWalletServiceResponsePromise<Nip47SignMessageResponse>;
}



================================================
FILE: src/nwc/types.ts
================================================
export type Nip47EncryptionType = "nip04" | "nip44_v2";

export type NWCAuthorizationUrlOptions = {
  name?: string;
  icon?: string;
  requestMethods?: Nip47Method[];
  notificationTypes?: Nip47NotificationType[];
  returnTo?: string;
  expiresAt?: Date;
  maxAmount?: number;
  budgetRenewal?: "never" | "daily" | "weekly" | "monthly" | "yearly";
  isolated?: boolean;
  metadata?: unknown;
};

export class Nip47Error extends Error {
  code: string;
  constructor(message: string, code: string) {
    super(message);
    this.code = code;
  }
}

export class Nip47NetworkError extends Nip47Error {}

/**
 * A NIP-47 response was received, but with an error code (see https://github.com/nostr-protocol/nips/blob/master/47.md#error-codes)
 */
export class Nip47WalletError extends Nip47Error {}

export class Nip47TimeoutError extends Nip47Error {}
export class Nip47PublishTimeoutError extends Nip47TimeoutError {}
export class Nip47ReplyTimeoutError extends Nip47TimeoutError {}
export class Nip47PublishError extends Nip47Error {}
export class Nip47ResponseDecodingError extends Nip47Error {}
export class Nip47ResponseValidationError extends Nip47Error {}
export class Nip47UnexpectedResponseError extends Nip47Error {}
export class Nip47UnsupportedEncryptionError extends Nip47Error {}

export type WithDTag = {
  dTag: string;
};

export type WithOptionalId = {
  id?: string;
};

export type Nip47SingleMethod =
  | "get_info"
  | "get_balance"
  | "get_budget"
  | "make_invoice"
  | "pay_invoice"
  | "pay_keysend"
  | "lookup_invoice"
  | "list_transactions"
  | "sign_message"
  | "create_connection"
  | "make_hold_invoice"
  | "settle_hold_invoice"
  | "cancel_hold_invoice";

export type Nip47MultiMethod = "multi_pay_invoice" | "multi_pay_keysend";

export type Nip47Method = Nip47SingleMethod | Nip47MultiMethod;
export type Nip47Capability = Nip47Method | "notifications";
export type BudgetRenewalPeriod =
  | "daily"
  | "weekly"
  | "monthly"
  | "yearly"
  | "never";

export type Nip47GetInfoResponse = {
  alias: string;
  color: string;
  pubkey: string;
  network: string;
  block_height: number;
  block_hash: string;
  methods: Nip47Method[];
  notifications?: Nip47NotificationType[];
  metadata?: unknown;
  lud16?: string;
};

export type Nip47GetBudgetResponse =
  | {
      used_budget: number; // msats
      total_budget: number; // msats
      renews_at?: number; // timestamp
      renewal_period: BudgetRenewalPeriod;
    }
  // eslint-disable-next-line @typescript-eslint/ban-types
  | {};

export type Nip47GetBalanceResponse = {
  balance: number; // msats
};

export type Nip47PayResponse = {
  preimage: string;
  fees_paid: number;
};

export type Nip47MultiPayInvoiceRequest = {
  invoices: (Nip47PayInvoiceRequest & WithOptionalId)[];
};

export type Nip47MultiPayKeysendRequest = {
  keysends: (Nip47PayKeysendRequest & WithOptionalId)[];
};

export type Nip47MultiPayInvoiceResponse = {
  invoices: ({ invoice: Nip47PayInvoiceRequest } & Nip47PayResponse &
    WithDTag)[];
  errors: []; // TODO: add error handling
};
export type Nip47MultiPayKeysendResponse = {
  keysends: ({ keysend: Nip47PayKeysendRequest } & Nip47PayResponse &
    WithDTag)[];
  errors: []; // TODO: add error handling
};

export interface Nip47ListTransactionsRequest {
  from?: number;
  until?: number;
  limit?: number;
  offset?: number;
  unpaid?: boolean;
  /**
   * NOTE: non-NIP-47 spec compliant
   */
  unpaid_outgoing?: boolean;
  /**
   * NOTE: non-NIP-47 spec compliant
   */
  unpaid_incoming?: boolean;
  type?: "incoming" | "outgoing";
}

export type Nip47ListTransactionsResponse = {
  transactions: Nip47Transaction[];
  /**
   * NOTE: non-NIP-47 spec compliant
   */
  total_count: number;
};

export type Nip47Transaction = {
  type: "incoming" | "outgoing";
  /**
   * NOTE: non-NIP-47 spec compliant
   */
  state: "settled" | "pending" | "failed";
  invoice: string;
  description: string;
  description_hash: string;
  preimage: string;
  payment_hash: string;
  amount: number;
  fees_paid: number;
  settled_at: number;
  created_at: number;
  expires_at: number;
  /**
   * NOTE: non-NIP-47 spec compliant
   */
  settle_deadline?: number;
  metadata?: Nip47TransactionMetadata;
};

export type Nip47TransactionMetadata = {
  comment?: string; // LUD-12
  payer_data?: {
    email?: string;
    name?: string;
    pubkey?: string;
  }; // LUD-18
  recipient_data?: {
    identifier?: string;
  }; // LUD-18
  nostr?: {
    pubkey: string;
    tags: string[][];
  }; // NIP-57
} & Record<string, unknown>;

export type Nip47NotificationType = Nip47Notification["notification_type"];

export type Nip47Notification =
  | {
      notification_type: "payment_received";
      notification: Nip47Transaction;
    }
  | {
      notification_type: "payment_sent";
      notification: Nip47Transaction;
    }
  | {
      notification_type: "hold_invoice_accepted";
      notification: Nip47Transaction;
    };

export type Nip47PayInvoiceRequest = {
  invoice: string;
  metadata?: Nip47TransactionMetadata;
  amount?: number; // msats
};

export type Nip47PayKeysendRequest = {
  amount: number; //msat
  pubkey: string;
  preimage?: string;
  tlv_records?: { type: number; value: string }[];
};

export type Nip47MakeInvoiceRequest = {
  amount: number; //msat
  description?: string;
  description_hash?: string;
  expiry?: number; // in seconds
  metadata?: Nip47TransactionMetadata;
};

export type Nip47MakeHoldInvoiceRequest = Nip47MakeInvoiceRequest & {
  payment_hash: string;
};

export type Nip47SettleHoldInvoiceRequest = {
  preimage: string;
};
// eslint-disable-next-line @typescript-eslint/ban-types
export type Nip47SettleHoldInvoiceResponse = {};

export type Nip47CancelHoldInvoiceRequest = {
  payment_hash: string;
};
// eslint-disable-next-line @typescript-eslint/ban-types
export type Nip47CancelHoldInvoiceResponse = {};

export type Nip47LookupInvoiceRequest = {
  payment_hash?: string;
  invoice?: string;
};

export type Nip47SignMessageRequest = {
  message: string;
};

export type Nip47CreateConnectionRequest = {
  pubkey: string;
  name: string;
  request_methods: Nip47Method[];
  notification_types?: Nip47NotificationType[];
  max_amount?: number;
  budget_renewal?: BudgetRenewalPeriod;
  expires_at?: number;
  isolated?: boolean;
  metadata?: unknown;
};

export type Nip47CreateConnectionResponse = {
  wallet_pubkey: string;
};

export type Nip47SignMessageResponse = {
  message: string;
  signature: string;
};

export type Nip47TimeoutValues = {
  replyTimeout?: number;
  publishTimeout?: number;
};



================================================
FILE: src/oauth/AlbyResponseError.test.ts
================================================
import { AlbyResponseError } from "./AlbyResponseError";
import "websocket-polyfill";

describe("AlbyResponseError", () => {
  test("Error message is generated", () => {
    expect(
      new AlbyResponseError(
        500,
        "Internal Server Error",
        new Headers(),
        new Error("Something went wrong"),
      ).message,
    ).toEqual("500 Internal Server Error: Something went wrong");
  });
});



================================================
FILE: src/oauth/AlbyResponseError.ts
================================================
export class AlbyResponseError extends Error {
  status: number;
  statusText: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  headers: Record<string, any>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  error: any; // todo: typeable?
  constructor(
    status: number,
    statusText: string,
    headers: Headers,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error: any,
  ) {
    let message = status.toString();
    if (statusText) {
      message += ` ${statusText}`;
    }
    message += ": ";
    if (error.message) {
      message += error.message;
    } else {
      message += JSON.stringify(error);
    }

    super(message);
    this.status = status;
    this.statusText = statusText;
    this.headers = headers;
    this.error = error;
  }
}



================================================
FILE: src/oauth/auth.ts
================================================
export * from "./OAuth2User";
export * from "./OAuth2Bearer";



================================================
FILE: src/oauth/client.ts
================================================
import { SignMessageResponse } from "@webbtc/webln-types";
import { OAuth2Bearer } from "./auth";
import { keysendParamsFromBoostagram } from "./helpers";
import { RequestOptions, rest } from "./request";
import {
  AuthClient,
  BaseWebhookEndpointResponse,
  CreateSwapParams,
  CreateSwapResponse,
  CreateWebhookEndpointParams,
  CreateWebhookEndpointResponse,
  DecodedInvoice,
  GetAccountBalanceResponse,
  GetAccountInformationResponse,
  GetInvoicesRequestParams,
  Invoice,
  InvoiceRequestParams,
  KeysendRequestParams,
  SendBoostagramRequestParams,
  SendPaymentRequestParams,
  SendPaymentResponse,
  SendBoostagramToAlbyRequestParams,
  SwapInfoResponse,
  SignMessageRequestParams,
} from "./types";

export class Client {
  auth: AuthClient;
  defaultRequestOptions?: Partial<RequestOptions>;

  constructor(
    auth: string | AuthClient,
    requestOptions?: Partial<RequestOptions>,
  ) {
    this.auth = typeof auth === "string" ? new OAuth2Bearer(auth) : auth;
    this.defaultRequestOptions = {
      ...requestOptions,
      user_agent: requestOptions?.user_agent,
    };
  }

  accountBalance(
    // eslint-disable-next-line @typescript-eslint/ban-types
    params: {},
    request_options?: Partial<RequestOptions>,
  ): Promise<GetAccountBalanceResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/balance`,
      params,
      method: "GET",
    });
  }

  signMessage(
    message: SignMessageRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<SignMessageResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/signatures`,
      request_body: message,
      method: "POST",
    });
  }

  accountSummary(
    // eslint-disable-next-line @typescript-eslint/ban-types
    params: {},
    request_options?: Partial<RequestOptions>,
  ) {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/user/summary`,
      params,
      method: "GET",
    });
  }

  accountInformation(
    // eslint-disable-next-line @typescript-eslint/ban-types
    params: {},
    request_options?: Partial<RequestOptions>,
  ): Promise<GetAccountInformationResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/user/me`,
      params,
      method: "GET",
    });
  }

  accountValue4Value(
    // eslint-disable-next-line @typescript-eslint/ban-types
    params: {},
    request_options?: Partial<RequestOptions>,
  ) {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/user/value4value`,
      params,
      method: "GET",
    });
  }

  incomingInvoices(
    params: GetInvoicesRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<Invoice[]> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/invoices/incoming`,
      params,
      method: "GET",
    });
  }

  outgoingInvoices(
    params: GetInvoicesRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<Invoice[]> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/invoices/outgoing`,
      params,
      method: "GET",
    });
  }

  invoices(
    params: GetInvoicesRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<Invoice[]> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/invoices`,
      params,
      method: "GET",
    });
  }

  getInvoice(
    paymentHash: string,
    request_options?: Partial<RequestOptions>,
  ): Promise<Invoice> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/invoices/${paymentHash}`,
      method: "GET",
    });
  }

  decodeInvoice(
    paymentRequest: string,
    request_options?: Partial<RequestOptions>,
  ): Promise<DecodedInvoice> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/decode/bolt11/${paymentRequest}`,
      method: "GET",
    });
  }

  createInvoice(
    invoice: InvoiceRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<Invoice> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/invoices`,
      request_body: invoice,
      method: "POST",
    });
  }

  keysend(
    args: KeysendRequestParams | KeysendRequestParams[],
    request_options?: Partial<RequestOptions>,
  ): Promise<SendPaymentResponse> {
    let endpoint, request_body;
    if (Array.isArray(args)) {
      endpoint = "/payments/keysend/multi";
      request_body = {
        keysends: args.map((args) => ({
          ...args,
          custom_records: args.customRecords,
        })),
      };
    } else {
      endpoint = "/payments/keysend";
      request_body = {
        ...args,
        custom_records: args.customRecords,
      };
    }
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint,
      request_body,
      method: "POST",
    });
  }

  sendPayment(
    params: SendPaymentRequestParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<SendPaymentResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/payments/bolt11`,
      request_body: params,
      method: "POST",
    });
  }

  sendBoostagram(
    args: SendBoostagramRequestParams | SendBoostagramRequestParams[],
    request_options?: Partial<RequestOptions>,
  ) {
    let endpoint, request_body;
    if (Array.isArray(args)) {
      endpoint = "/payments/keysend/multi";
      const keysends = args.map((b) => keysendParamsFromBoostagram(b));
      request_body = { keysends };
    } else {
      endpoint = "/payments/keysend";
      request_body = keysendParamsFromBoostagram(args);
    }

    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint,
      request_body,
      method: "POST",
    });
  }

  sendBoostagramToAlbyAccount(
    args: SendBoostagramToAlbyRequestParams,
    request_options?: Partial<RequestOptions>,
  ) {
    const params = {
      destination:
        "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3",
      custom_records: {
        "696969": args.account,
      },
      amount: args.amount,
      memo: args.memo,
    };
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/payments/keysend`,
      request_body: params,
      method: "POST",
    });
  }

  createWebhookEndpoint(
    params: CreateWebhookEndpointParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<CreateWebhookEndpointResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/webhook_endpoints`,
      request_body: params,
      method: "POST",
    });
  }

  deleteWebhookEndpoint(
    id: string,
    request_options?: Partial<RequestOptions>,
  ): Promise<BaseWebhookEndpointResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/webhook_endpoints/${id}`,
      method: "DELETE",
    });
  }

  getSwapInfo(
    request_options?: Partial<RequestOptions>,
  ): Promise<SwapInfoResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/swaps/info`,
      method: "GET",
    });
  }

  createSwap(
    params: CreateSwapParams,
    request_options?: Partial<RequestOptions>,
  ): Promise<CreateSwapResponse> {
    return rest({
      auth: this.auth,
      ...this.defaultRequestOptions,
      ...request_options,
      endpoint: `/swaps`,
      method: "POST",
      request_body: params,
    });
  }
}



================================================
FILE: src/oauth/helpers.ts
================================================
import { SendBoostagramRequestParams } from "./types";

export function keysendParamsFromBoostagram(
  boostagramParams: SendBoostagramRequestParams,
) {
  const customRecords: Record<string, string> = {};
  if (
    boostagramParams.recipient.customKey &&
    boostagramParams.recipient.customValue
  ) {
    customRecords[boostagramParams.recipient.customKey] =
      boostagramParams.recipient.customValue;
  }
  // https://github.com/lightning/blips/blob/master/blip-0010.md
  customRecords["7629169"] = JSON.stringify(boostagramParams.boostagram);

  return {
    destination: boostagramParams.recipient.address,
    amount: boostagramParams.amount,
    custom_records: customRecords,
  };
}



================================================
FILE: src/oauth/index.ts
================================================
export * as auth from "./auth";
export * as types from "./types";
export * as utils from "./utils";
export { Client } from "./client";



================================================
FILE: src/oauth/OAuth2Bearer.ts
================================================
import { AuthClient, AuthHeader } from "./types";

export class OAuth2Bearer implements AuthClient {
  private bearer_token: string;

  constructor(bearer_token: string) {
    this.bearer_token = bearer_token;
  }

  getAuthHeader(): AuthHeader {
    return {
      Authorization: `Bearer ${this.bearer_token}`,
    };
  }
}



================================================
FILE: src/oauth/OAuth2User.ts
================================================
import { EventEmitter } from "./eventEmitter/EventEmitter";
import { RequestOptions, rest } from "./request";
import {
  AuthHeader,
  EventName,
  EventListener,
  GenerateAuthUrlOptions,
  GetTokenResponse,
  OAuthClient,
  Token,
} from "./types";
import { basicAuthHeader, buildQueryString } from "./utils";
import { toHexString } from "../utils";

const AUTHORIZE_URL = "https://getalby.com/oauth";

export type OAuth2Scopes =
  | "account:read"
  | "invoices:create"
  | "invoices:read"
  | "transactions:read"
  | "balance:read"
  | "payments:send";

export interface OAuth2UserOptions {
  client_id: string;
  client_secret?: string;
  callback: string;
  scopes: OAuth2Scopes[];
  request_options?: Partial<RequestOptions>;
  user_agent: string;
  token?: Token;
}

function processTokenResponse(token: GetTokenResponse): Token {
  const { expires_in, ...rest } = token;
  return {
    ...rest,
    ...(!!expires_in && {
      expires_at: Date.now() + expires_in * 1000,
    }),
  };
}

export class OAuth2User implements OAuthClient {
  token?: Token;
  options: OAuth2UserOptions;
  code_verifier?: string;
  code_challenge?: string;
  private _refreshAccessTokenPromise: Promise<{ token: Token }> | null;
  private _tokenEvents: EventEmitter;

  constructor(options: OAuth2UserOptions) {
    this._tokenEvents = new EventEmitter();
    const { token, ...defaultOptions } = options;
    this.options = { client_secret: "", ...defaultOptions };
    this.token = token;
    this._refreshAccessTokenPromise = null;
  }

  /**
   * Subscribe to the events
   */
  on(eventName: EventName, listener: EventListener): void {
    this._tokenEvents.on(eventName, listener);
  }

  /**
   * Refresh the access token
   */
  async refreshAccessToken(): Promise<{ token: Token }> {
    if (this._refreshAccessTokenPromise) {
      return this._refreshAccessTokenPromise;
    }
    // eslint-disable-next-line no-async-promise-executor
    this._refreshAccessTokenPromise = new Promise(async (resolve, reject) => {
      try {
        const refresh_token = this.token?.refresh_token;
        const { client_id, client_secret, request_options, user_agent } =
          this.options;
        if (!client_id) {
          throw new Error("client_id is required");
        }
        if (!refresh_token) {
          throw new Error("refresh_token is required");
        }
        const data = await rest<GetTokenResponse>({
          ...request_options,
          endpoint: `/oauth/token`,
          params: {
            client_id,
            grant_type: "refresh_token",
            refresh_token,
          },
          user_agent,
          method: "POST",
          headers: {
            ...request_options?.headers,
            "Content-type": "application/x-www-form-urlencoded",
            ...{
              Authorization: basicAuthHeader(client_id, client_secret),
            },
          },
        });
        const token = processTokenResponse(data);
        this.token = token;
        resolve({ token });
        this._tokenEvents.emit("tokenRefreshed", this.token);
      } catch (error) {
        console.error(error);
        reject(error);
        this._tokenEvents.emit("tokenRefreshFailed", error as Error);
      } finally {
        this._refreshAccessTokenPromise = null;
      }
    });
    return this._refreshAccessTokenPromise;
  }

  /**
   * Check if an access token is expired
   */
  isAccessTokenExpired(): boolean {
    const refresh_token = this.token?.refresh_token;
    const expires_at = this.token?.expires_at;
    if (!expires_at) return true;
    return !!refresh_token && expires_at <= Date.now() + 1000;
  }

  /**
   * Request an access token
   */
  async requestAccessToken(code?: string): Promise<{ token: Token }> {
    const { client_id, client_secret, callback, request_options, user_agent } =
      this.options;
    const code_verifier = this.code_verifier;
    if (!client_id) {
      throw new Error("client_id is required");
    }
    if (!client_secret && !code_verifier) {
      throw new Error(
        "either client_secret is required, or code should be generated using a challenge",
      );
    }
    if (!callback) {
      throw new Error("callback is required");
    }
    const params = {
      code,
      grant_type: "authorization_code",
      code_verifier,
      client_id,
      redirect_uri: callback,
    };
    const data = await rest<GetTokenResponse>({
      ...request_options,
      endpoint: `/oauth/token`,
      params,
      user_agent,
      method: "POST",
      headers: {
        ...request_options?.headers,
        "Content-Type": "application/x-www-form-urlencoded",
        ...{
          Authorization: basicAuthHeader(client_id, client_secret),
        },
      },
    });
    const token = processTokenResponse(data);
    this.token = token;
    return { token };
  }

  async generateAuthURL(options?: GenerateAuthUrlOptions): Promise<string> {
    if (!options) {
      options = {};
    }
    const { client_id, callback, scopes } = this.options;
    if (!callback) throw new Error("callback required");
    if (!scopes) throw new Error("scopes required");
    let code_challenge_method;
    if (options.code_challenge_method === "S256") {
      await this._generateS256Challenge();
      code_challenge_method = "S256";
    } else if (
      options.code_challenge_method === "plain" &&
      options.code_challenge
    ) {
      this.code_challenge = options.code_challenge;
      this.code_verifier = options.code_challenge;
      code_challenge_method = "plain";
    }
    const code_challenge = this.code_challenge;
    const url = new URL(options.authorizeUrl || AUTHORIZE_URL);
    url.search = buildQueryString({
      ...options,
      client_id,
      scope: scopes.join(" "),
      response_type: "code",
      redirect_uri: callback,
      code_challenge_method,
      code_challenge,
    });
    return url.toString();
  }

  async getAuthHeader(): Promise<AuthHeader> {
    if (!this.token?.access_token) throw new Error("access_token is required");
    if (this.isAccessTokenExpired()) {
      await this.refreshAccessToken();
    }
    return {
      Authorization: `Bearer ${this.token.access_token}`,
    };
  }

  private async _generateS256Challenge() {
    const codeVerifierBytes = crypto.getRandomValues(new Uint8Array(64));
    this.code_verifier = toHexString(codeVerifierBytes);

    // from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
    const hashBuffer = await crypto.subtle.digest(
      "SHA-256",
      new TextEncoder().encode(this.code_verifier),
    );
    const hashArray = new Uint8Array(hashBuffer);

    // from https://stackoverflow.com/a/45313868
    // TODO: consider using Buffer.from(hashBuffer).toString("base64") in NodeJS
    this.code_challenge = btoa(String.fromCharCode(...hashArray))
      // from https://gist.github.com/jhurliman/1250118?permalink_comment_id=3194799
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=+$/, "");
  }
}



================================================
FILE: src/oauth/request.ts
================================================
import { buildQueryString } from "./utils";
import { AlbyResponseError, AuthClient } from "./types";

const BASE_URL = "https://api.getalby.com";

export interface RequestOptions extends Omit<RequestInit, "body"> {
  auth?: AuthClient;
  endpoint: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  params?: Record<string, any>;
  user_agent?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  request_body?: Record<string, any>;
  method?: string;
  max_retries?: number;
  base_url?: string;
}

async function fetchWithRetries(
  url: RequestInfo,
  init: RequestInit,
  max_retries = 0,
): Promise<Response> {
  const res = await fetch(url, init);
  if (res.status === 429 && max_retries > 0) {
    const rateLimitReset = Number(res.headers.get("x-rate-limit-reset"));
    const rateLimitRemaining = Number(
      res.headers.get("x-rate-limit-remaining"),
    );
    const timeTillReset = rateLimitReset * 1000 - Date.now();
    let timeToWait = 1000;
    if (rateLimitRemaining === 0) timeToWait = timeTillReset;
    await new Promise((resolve) => setTimeout(resolve, timeToWait));
    return fetchWithRetries(url, init, max_retries - 1);
  }
  return res;
}

export async function request({
  auth,
  endpoint,
  params: query = {},
  request_body,
  method,
  max_retries,
  base_url = BASE_URL,
  user_agent,
  headers,
  ...options
}: RequestOptions): Promise<Response> {
  const url = new URL(base_url + endpoint);
  url.search = buildQueryString(query);
  const isPost = method === "POST" && !!request_body;
  const authHeader = auth
    ? await auth.getAuthHeader(url.href, method)
    : undefined;
  const response = await fetchWithRetries(
    url.toString(),
    {
      headers: {
        ...(isPost
          ? { "Content-Type": "application/json; charset=utf-8" }
          : undefined),
        ...authHeader,
        ...headers,
        ...{
          "User-Agent": user_agent ?? "@getalby/sdk",
          "X-User-Agent": user_agent ?? "@getalby/sdk",
        },
      },
      method,
      body: isPost ? JSON.stringify(request_body) : undefined,
      ...options,
    },
    max_retries,
  );
  if (!response.ok) {
    const error = await response.json();
    throw new AlbyResponseError(
      response.status,
      response.statusText,
      response.headers,
      error,
    );
  }
  return response;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function rest<T = any>(args: RequestOptions): Promise<T> {
  const response = await request(args);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return response.json() as any;
}



================================================
FILE: src/oauth/types.ts
================================================
import { AlbyResponseError } from "./AlbyResponseError";
import type { RequestOptions } from "./request";

export type SuccessStatus = 200 | 201;
export type ResponseType = "application/json";

export type TokenRefreshedListener = (tokens: Token) => void;
export type TokenRefreshFailedListener = (error: Error) => void;
export type EventName = "tokenRefreshed" | "tokenRefreshFailed";
export type EventListener = TokenRefreshedListener | TokenRefreshFailedListener;

export interface AuthHeader {
  Authorization: string;
}

export interface GetTokenResponse {
  /** Allows an application to obtain a new access token without prompting the user via the refresh token flow. */
  refresh_token?: string;
  /** Access tokens are the token that applications use to make API requests on behalf of a user.  */
  access_token?: string;
  token_type?: string;
  expires_in?: number;
  /** Comma-separated list of scopes for the token  */
  scope?: string;
}

export interface Token extends Omit<GetTokenResponse, "expires_in"> {
  /** Date that the access_token will expire at.  */
  expires_at?: number;
}

export type GenerateAuthUrlOptions = { authorizeUrl?: string } & (
  | {
      code_challenge_method?: string;
      code_challenge?: string;
    }
  | {
      /** A random string you provide to verify against CSRF attacks.  The length of this string can be up to 500 characters. */
      state?: string;
      /** Specifies the method you are using to make a request (S256 OR plain). */
      code_challenge_method: "S256";
    }
  | {
      /** A random string you provide to verify against CSRF attacks.  The length of this string can be up to 500 characters. */
      state: string;
      /** A PKCE parameter, a random secret for each request you make. */
      code_challenge: string;
      /** Specifies the method you are using to make a request (S256 OR plain). */
      code_challenge_method?: "plain";
    }
);

export abstract class OAuthClient implements AuthClient {
  abstract token?: Token;
  abstract generateAuthURL(options: GenerateAuthUrlOptions): Promise<string>;
  abstract requestAccessToken(code?: string): Promise<{ token: Token }>;
  abstract getAuthHeader(
    url?: string,
    method?: string,
  ): Promise<AuthHeader> | AuthHeader;
}

export abstract class AuthClient {
  abstract getAuthHeader(
    url?: string,
    method?: string,
  ): Promise<AuthHeader> | AuthHeader;
}

// https://stackoverflow.com/a/50375286
export type UnionToIntersection<U> =
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (U extends any ? (k: U) => void : never) extends (k: infer I) => void
    ? I
    : never;

export type GetSuccess<T> = {
  [K in SuccessStatus & keyof T]: GetContent<T[K]>;
}[SuccessStatus & keyof T];

export type AlbyResponse<T> = UnionToIntersection<ExtractAlbyResponse<T>>;

export type GetContent<T> = "content" extends keyof T
  ? ResponseType extends keyof T["content"]
    ? T["content"][ResponseType]
    : never
  : never;

export type ExtractAlbyResponse<T> = "responses" extends keyof T
  ? GetSuccess<T["responses"]>
  : never;

export type GetInvoicesRequestParams = {
  q?: {
    since?: string;
    created_at_lt?: string;
    created_at_gt?: string;
  };
  page?: number;
  items?: number;
};

export type InvoiceRequestParams = {
  description?: string;
  description_hash?: string;
  amount: number;
};

export type KeysendRequestParams = {
  amount: number;
  destination: string;
  memo?: string;
  customRecords?: Record<string, string>;
};

export type SendPaymentRequestParams = {
  invoice: string;
  amount?: number;
};

export type SendBoostagramRequestParams = {
  recipient: {
    address: string;
    customKey?: string;
    customValue?: string;
  };
  boostagram: unknown;
  amount: number;
};

export type SendBoostagramToAlbyRequestParams = {
  /**
   * the keysend custom value found at https://getalby.com/node
   */
  account: string;
  amount: number;
  memo?: string;
};

export type CreateWebhookEndpointParams = {
  url: string;
  description?: string;
  filter_types: string[];
};

export type BaseWebhookEndpointResponse = {
  url: string;
  description?: string;
  filter_types: string[];
  created_at: string;
  id: string;
};

export type SwapInfoResponse = {
  available: boolean;
  service_fee_percentage: number;
  network_fee: number;
  sats_per_vbyte: number;
};

export type CreateSwapParams = {
  amount: number;
  address: string;
  sats_per_vbyte: number;
};

export type CreateSwapResponse = {
  address: string;
  service_fee: number;
  network_fee: number;
  amount: number;
  total: number;
  payment_request: string;
};

export type CreateWebhookEndpointResponse = BaseWebhookEndpointResponse & {
  endpoint_secret: string;
};

export type Invoice = {
  amount: number;
  boostagram?: {
    podcast: string;
    feedID?: number;
    itemID: number;
    episode: string;
    ts: number;
    action: string;
    app_name: string;
    app_version: string;
    value_msat: number;
    value_msat_total: number;
    name: string;
    message: string;
    sender_name: string;
    episode_guid?: string;
    boost_link?: string;
    url?: string;
    guid?: string;
  } & Record<string, unknown>;
  comment?: string;
  created_at: string;
  creation_date: number;
  currency: string;
  custom_records: Record<string, string>;
  description_hash: null;
  expires_at: string;
  expiry: number;
  fiat_currency: string;
  fiat_in_cents: number;
  identifier: string;
  keysend_message?: string;
  memo: string;
  payer_name: string;
  payer_pubkey?: string;
  payment_hash: string;
  payment_request: string;
  preimage?: string;
  r_hash_str: string;
  settled: boolean;
  settled_at: string;
  state: string;
  type: string;
  value: number;
  metadata?: {
    // TODO: add typings
    payer_data?: unknown;
    zap_request?: unknown;
  };
} & Record<string, unknown>;

export type SendPaymentResponse = {
  amount: number;
  description: string;
  destination: string;
  fee: number;
  payment_hash: string;
  payment_preimage: string;
  payment_request: string;
};

export type GetAccountBalanceResponse = {
  balance: number;
  currency: string;
  unit: string;
};

export type SignMessageRequestParams = {
  message: string;
};

export type GetAccountInformationResponse = {
  identifier: string;
  email: string;
  name?: string;
  avatar?: string;
  keysend_custom_key: string;
  keysend_custom_value: string;
  keysend_pubkey: string;
  lightning_address?: string;
  nostr_pubkey?: string;
};

export type DecodedInvoice = {
  currency: string;
  /**
   * unix timestamp in seconds
   */
  created_at: number;
  /**
   * expiry from the created_at time in seconds (not a timestamp)
   */
  expiry: number;
  payee: string;
  msatoshi: number;
  description: string;
  payment_hash: string;
  min_final_cltv_expiry: number;
  amount: number;
  payee_alias: string;
};

export { AlbyResponseError, RequestOptions };



================================================
FILE: src/oauth/utils.ts
================================================
// https://stackoverflow.com/a/62969380 + fix to remove empty entries (.filter(entry => entry))
export function buildQueryString(query: Record<string, unknown>): string {
  return Object.entries(query)
    .map(([key, value]) => (key && value ? `${key}=${value}` : ""))
    .filter((entry) => entry)
    .join("&");
}

export function basicAuthHeader(
  client_id: string,
  client_secret: string | undefined,
) {
  return `Basic ${btoa(`${client_id}:${client_secret}`)}`;
}



================================================
FILE: src/oauth/eventEmitter/EventEmitter.ts
================================================
import { EventListener, EventName, Token } from "../types";

export class EventEmitter {
  private events: { [key: string]: EventListener[] } = {};

  on(event: EventName, listener: EventListener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  off(event: EventName, listener: EventListener) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter((l) => l !== listener);
  }

  emit(event: EventName, payload: Token | Error) {
    if (!this.events[event]) return;
    this.events[event].forEach((listener) =>
      listener(payload as Token & Error),
    );
  }
}



================================================
FILE: src/webln/index.ts
================================================
export * from "./NostrWeblnProvider";
export * from "./OauthWeblnProvider";



================================================
FILE: src/webln/NostrWeblnProvider.ts
================================================
import { Event, UnsignedEvent } from "nostr-tools";
import {
  GetBalanceResponse,
  KeysendArgs,
  RequestInvoiceArgs,
  SendPaymentResponse,
  SignMessageResponse,
  WebLNNode,
  WebLNProvider,
  WebLNRequestMethod,
  LookupInvoiceArgs,
  LookupInvoiceResponse,
  WebLNMethod,
  MakeInvoiceResponse,
} from "@webbtc/webln-types";
import { GetInfoResponse } from "@webbtc/webln-types";
import { NWCClient, NWCOptions, NewNWCClientOptions } from "../nwc/NWCClient";
import {
  Nip47Method,
  Nip47PayKeysendRequest,
  Nip47Transaction,
  NWCAuthorizationUrlOptions,
} from "../nwc/types";
import { toHexString } from "../utils";

// TODO: review fields (replace with camelCase)
// TODO: consider move to webln-types package
export type Transaction = Nip47Transaction;

// TODO: consider moving to webln-types package
export type ListTransactionsResponse = {
  transactions: Transaction[];
};

// TODO: consider moving to webln-types package
export type ListTransactionsArgs = {
  from?: number;
  until?: number;
  limit?: number;
  offset?: number;
  unpaid?: boolean;
  type?: "incoming" | "outgoing";
};

// TODO: consider moving to webln-types package
export type SendMultiPaymentResponse = {
  payments: ({ paymentRequest: string } & SendPaymentResponse)[];
  errors: { paymentRequest: string; message: string }[];
};

// TODO: consider moving to webln-types package
export type MultiKeysendResponse = {
  keysends: ({ keysend: KeysendArgs } & SendPaymentResponse)[];
  errors: { keysend: KeysendArgs; message: string }[];
};

type NostrWebLNOptions = NWCOptions;

export type Nip07Provider = {
  getPublicKey(): Promise<string>;
  signEvent(event: UnsignedEvent): Promise<Event>;
};

const nip47ToWeblnRequestMap: Record<
  Exclude<
    Nip47Method,
    | "get_budget"
    | "create_connection"
    | "make_hold_invoice"
    | "settle_hold_invoice"
    | "cancel_hold_invoice"
  >,
  WebLNMethod
> = {
  get_info: "getInfo",
  get_balance: "getBalance",
  make_invoice: "makeInvoice",
  pay_invoice: "sendPayment",
  pay_keysend: "payKeysend",
  lookup_invoice: "lookupInvoice",
  list_transactions: "listTransactions",
  multi_pay_invoice: "sendMultiPayment",
  multi_pay_keysend: "multiKeysend",
  sign_message: "signMessage",
};

export type NewNostrWeblnProviderOptions = NewNWCClientOptions & {
  client?: NWCClient;
};

export class NostrWebLNProvider implements WebLNProvider, Nip07Provider {
  private _enabled = false;
  readonly client: NWCClient;
  readonly subscribers: Record<string, (payload: unknown) => void>;

  get options(): NostrWebLNOptions {
    return this.client.options;
  }

  static async fromAuthorizationUrl(
    authorizationBasePath: string,
    options: NWCAuthorizationUrlOptions = {},
    secret?: string,
  ) {
    const client = await NWCClient.fromAuthorizationUrl(
      authorizationBasePath,
      options,
      secret,
    );
    return new NostrWebLNProvider({
      client,
    });
  }

  constructor(options?: NewNostrWeblnProviderOptions) {
    this.client = options?.client || new NWCClient(options);

    this.subscribers = {};
  }

  on(name: string, callback: () => void) {
    this.subscribers[name] = callback;
  }

  notify(name: WebLNMethod, payload?: unknown) {
    const callback = this.subscribers[name];
    if (callback) {
      callback(payload);
    }
  }

  getPublicKey(): Promise<string> {
    return this.client.getPublicKey();
  }

  signEvent(event: UnsignedEvent): Promise<Event> {
    return this.client.signEvent(event);
  }

  async enable() {
    this._enabled = true;
  }

  close() {
    return this.client.close();
  }

  async getInfo(): Promise<GetInfoResponse> {
    await this.checkEnabled();

    const supports = ["lightning", "nostr"];
    const version = "Alby JS SDK";

    try {
      const nip47Result = await this.client.getInfo();

      const result = {
        methods: nip47Result.methods.map(
          (key) =>
            nip47ToWeblnRequestMap[key as keyof typeof nip47ToWeblnRequestMap],
        ),
        node: {
          alias: nip47Result.alias,
          pubkey: nip47Result.pubkey,
          color: nip47Result.color,
        } as WebLNNode,
        supports,
        version,
      };

      this.notify("getInfo", result);
      return result;
    } catch (error) {
      console.error("Using minimal getInfo", error);
      return {
        methods: ["sendPayment"],
        node: {} as WebLNNode,
        supports,
        version,
      };
    }
  }

  async getBalance(): Promise<GetBalanceResponse> {
    await this.checkEnabled();
    const nip47Result = await this.client.getBalance();

    const result = {
      // NWC uses msats - convert to sats for webln
      balance: Math.floor(nip47Result.balance / 1000),
      currency: "sats",
    };
    this.notify("getBalance", result);
    return result;
  }

  async sendPayment(invoice: string): Promise<SendPaymentResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.payInvoice({ invoice });

    const result: SendPaymentResponse = { preimage: nip47Result.preimage };
    this.notify("sendPayment", result);

    return result;
  }

  async sendPaymentAsync(invoice: string): Promise<Record<string, never>> {
    await this.checkEnabled();

    // don't wait for the response'
    this.client.payInvoice({ invoice });

    this.notify("sendPaymentAsync", {});

    return {};
  }

  async keysend(args: KeysendArgs): Promise<SendPaymentResponse> {
    await this.checkEnabled();

    const nip47Result: SendPaymentResponse = await this.client.payKeysend(
      mapKeysendToNip47Keysend(args),
    );

    const result: SendPaymentResponse = { preimage: nip47Result.preimage };
    this.notify("keysend", result);

    return result;
  }

  async signMessage(message: string): Promise<SignMessageResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.signMessage({
      message,
    });

    const result: SignMessageResponse = {
      message: nip47Result.message,
      signature: nip47Result.signature,
    };
    this.notify("keysend", result);

    return result;
  }

  async makeInvoice(
    args: string | number | RequestInvoiceArgs,
  ): Promise<MakeInvoiceResponse> {
    await this.checkEnabled();

    const requestInvoiceArgs: RequestInvoiceArgs | undefined =
      typeof args === "object" ? (args as RequestInvoiceArgs) : undefined;
    const amount = +(requestInvoiceArgs?.amount ?? (args as string | number));

    if (!amount) {
      throw new Error("No amount specified");
    }

    const nip47Result = await this.client.makeInvoice({
      amount: amount * 1000, // NIP-47 uses msat
      description: requestInvoiceArgs?.defaultMemo,
      // TODO: support additional fields below
      //expiry: 86500,
      //description_hash: "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
    });

    const result: MakeInvoiceResponse = { paymentRequest: nip47Result.invoice };

    this.notify("makeInvoice", result);

    return result;
  }

  async lookupInvoice(args: LookupInvoiceArgs): Promise<LookupInvoiceResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.lookupInvoice({
      invoice: args.paymentRequest,
      payment_hash: args.paymentHash,
    });

    const result: LookupInvoiceResponse = {
      preimage: nip47Result.preimage,
      paymentRequest: nip47Result.invoice,
      paid: !!nip47Result.settled_at,
    };

    this.notify("lookupInvoice", result);

    return result;
  }

  async listTransactions(
    args: ListTransactionsArgs,
  ): Promise<ListTransactionsResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.listTransactions(args);

    const result: ListTransactionsResponse = {
      transactions: nip47Result.transactions.map(
        mapNip47TransactionToTransaction,
      ),
    };

    this.notify("listTransactions", result);

    return result;
  }

  // NOTE: this method may change - it has not been proposed to be added to the WebLN spec yet.
  async sendMultiPayment(
    paymentRequests: string[],
  ): Promise<SendMultiPaymentResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.multiPayInvoice({
      invoices: paymentRequests.map((paymentRequest, index) => ({
        invoice: paymentRequest,
        id: index.toString(),
      })),
    });

    const result = {
      payments: nip47Result.invoices.map((invoice) => {
        const paymentRequest = paymentRequests[parseInt(invoice.dTag)];
        if (!paymentRequest) {
          throw new Error(
            "Could not find paymentRequest matching response d tag",
          );
        }
        return {
          paymentRequest,
          preimage: invoice.preimage,
        };
      }),
      // TODO: error handling
      errors: [],
    };
    this.notify("sendMultiPayment", result);
    return result;
  }

  // NOTE: this method may change - it has not been proposed to be added to the WebLN spec yet.
  async multiKeysend(keysends: KeysendArgs[]): Promise<MultiKeysendResponse> {
    await this.checkEnabled();

    const nip47Result = await this.client.multiPayKeysend({
      keysends: keysends.map((keysend, index) => ({
        ...mapKeysendToNip47Keysend(keysend),
        id: index.toString(),
      })),
    });

    const result: MultiKeysendResponse = {
      keysends: nip47Result.keysends.map((result) => {
        const keysend = keysends[parseInt(result.dTag)];
        if (!keysend) {
          throw new Error("Could not find keysend matching response d tag");
        }
        return {
          keysend,
          preimage: result.preimage,
        };
      }),
      // TODO: error handling
      errors: [],
    };

    this.notify("multiKeysend", result);
    return result;
  }

  // not-yet implemented WebLN interface methods
  lnurl(
    lnurl: string,
  ): Promise<{ status: "OK" } | { status: "ERROR"; reason: string }> {
    throw new Error("Method not implemented.");
  }

  request(method: WebLNRequestMethod, args?: unknown): Promise<unknown> {
    throw new Error("Method not implemented.");
  }
  verifyMessage(signature: string, message: string): Promise<void> {
    throw new Error("Method not implemented.");
  }

  private async checkEnabled() {
    if (!this._enabled) {
      throw new Error(
        "please call enable() and await the promise before calling this function",
      );
    }
  }
}
function mapNip47TransactionToTransaction(
  transaction: Nip47Transaction,
): Transaction {
  return {
    ...transaction,
    // NWC uses msats - convert to sats for webln
    amount: Math.floor(transaction.amount / 1000),
    fees_paid: transaction.fees_paid
      ? Math.floor(transaction.fees_paid / 1000)
      : 0,
  };
}

function mapKeysendToNip47Keysend(args: KeysendArgs): Nip47PayKeysendRequest {
  return {
    amount: +args.amount * 1000, // NIP-47 uses msat
    pubkey: args.destination,
    tlv_records: args.customRecords
      ? Object.entries(args.customRecords).map((v) => ({
          type: parseInt(v[0]),
          value: toHexString(new TextEncoder().encode(v[1])),
        }))
      : [],
    // TODO: support optional preimage
    // preimage?: "123",
  };
}

export const NWC = NostrWebLNProvider;



================================================
FILE: src/webln/OauthWeblnProvider.ts
================================================
import { Client } from "../oauth/client";
import { OAuthClient, KeysendRequestParams } from "../oauth/types";

export interface RequestInvoiceArgs {
  amount: string | number;
  defaultMemo?: string;
}

const isBrowser = () =>
  typeof window !== "undefined" && typeof window.document !== "undefined";

export class OauthWeblnProvider {
  client: Client;
  auth: OAuthClient;
  oauth: boolean;
  subscribers: Record<string, (payload: unknown) => void>;
  isExecuting: boolean;

  constructor(options: { auth: OAuthClient }) {
    this.auth = options.auth;
    this.client = new Client(options.auth);
    this.oauth = true;
    this.subscribers = {};
    this.isExecuting = false;
  }

  on(name: string, callback: () => void) {
    this.subscribers[name] = callback;
  }

  notify(name: string, payload?: unknown) {
    const callback = this.subscribers[name];
    if (callback) {
      callback(payload);
    }
  }

  async enable() {
    if (this.isExecuting) {
      return;
    }
    if (this.auth.token?.access_token) {
      return { enabled: true };
    }
    if (isBrowser()) {
      try {
        this.isExecuting = true;
        await this.openAuthorization();
      } finally {
        this.isExecuting = false;
      }
    } else {
      throw new Error("Missing access token");
    }
  }

  async sendPayment(invoice: string) {
    if (this.isExecuting) {
      return;
    }
    try {
      this.isExecuting = true;
      const result = await this.client.sendPayment({ invoice });
      this.notify("sendPayment", result);
      return {
        preimage: result.payment_preimage,
      };
    } catch (error) {
      let message = "Unknown Error";
      if (error instanceof Error) message = error.message;
      throw new Error(message);
    } finally {
      this.isExecuting = false;
    }
  }

  async keysend(params: KeysendRequestParams) {
    if (this.isExecuting) {
      return;
    }
    try {
      this.isExecuting = true;
      const result = await this.client.keysend(params);
      this.notify("keysend", result);
      return {
        preimage: result.payment_preimage,
      };
    } catch (error) {
      let message = "Unknown Error";
      if (error instanceof Error) message = error.message;
      throw new Error(message);
    } finally {
      this.isExecuting = false;
    }
  }

  async getInfo() {
    return {
      alias: "Alby",
    };
  }

  async makeInvoice(params: RequestInvoiceArgs) {
    if (this.isExecuting) {
      return;
    }
    try {
      this.isExecuting = true;
      const result = await this.client.createInvoice({
        amount: parseInt(params.amount.toString()),
        description: params.defaultMemo,
      });
      this.notify("makeInvoice", result);
      return {
        paymentRequest: result.payment_request,
      };
    } catch (error) {
      let message = "Unknown Error";
      if (error instanceof Error) message = error.message;
      throw new Error(message);
    } finally {
      this.isExecuting = false;
    }
  }

  async openAuthorization() {
    const height = 700;
    const width = 600;
    const top = window.outerHeight / 2 + window.screenY - height / 2;
    const left = window.outerWidth / 2 + window.screenX - width / 2;
    const url = await this.auth.generateAuthURL({
      code_challenge_method: "S256",
    });

    return new Promise((resolve, reject) => {
      const popup = window.open(
        url,
        `${document.title} - WebLN enable`,
        `height=${height},width=${width},top=${top},left=${left}`,
      );
      let processingCode = false;
      window.addEventListener("message", async (message) => {
        const data = message.data;
        if (
          data &&
          data.type === "alby:oauth:success" &&
          message.origin ===
            `${document.location.protocol}//${document.location.host}` &&
          !processingCode
        ) {
          processingCode = true; // make sure we request the access token only once
          console.info("Processing OAuth code response");
          const code = data.payload.code;
          try {
            await this.auth.requestAccessToken(code);
            this.client = new Client(this.auth); // just to make sure we got a client with the correct auth and not the access token
            if (popup) {
              popup.close();
            }
            this.notify("enable");
            resolve({ enabled: true });
          } catch (e) {
            console.error(e);
            reject({ enabled: false });
          }
        }
      });
    });
  }
}



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  # Enable version updates for npm
  - package-ecosystem: "npm"
    # Look for `package.json` and `lock` files in the `root` directory
    directory: "/"
    # Check the npm registry for updates every day (weekdays)
    schedule:
      interval: "daily"



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches:
      - master
  pull_request:
    types: [opened, synchronize]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: "yarn"
      - run: yarn install --frozen-lockfile
      - run: yarn build
      - run: yarn test



================================================
FILE: .github/workflows/docs.yml
================================================
name: "typedoc"

on:
  push:
    branches: [feat/lnclient, master]

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # https://github.com/actions/checkout
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "yarn"
      - run: yarn install --frozen-lockfile
      # Generate your TypeDoc documentation
      - run: npx typedoc src/index.ts --out docs/generated
      # https://github.com/actions/upload-pages-artifact
      - uses: actions/upload-pages-artifact@v3
        with:
          path: ./docs/generated # This should be your TypeDoc "out" path.
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        # https://github.com/actions/deploy-pages
        uses: actions/deploy-pages@v4



================================================
FILE: .github/workflows/publish.yml
================================================
# This workflow will run tests using node and then publish a package to GitHub Packages when a release is created
# For more information see: https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages

name: Publish package

on:
  release:
    types: [published]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 20
      - run: yarn install --frozen-lockfile
      - run: yarn test

  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/
      - run: yarn install --frozen-lockfile
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{secrets.NPM_TOKEN}}



================================================
FILE: .husky/commit-msg
================================================
yarn commitlint --edit 



================================================
FILE: .husky/pre-commit
================================================
yarn lint-staged


